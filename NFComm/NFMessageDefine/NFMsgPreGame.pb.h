// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NFMsgPreGame.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_NFMsgPreGame_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_NFMsgPreGame_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "NFDefine.pb.h"
#include "NFMsgBase.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_NFMsgPreGame_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_NFMsgPreGame_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_NFMsgPreGame_2eproto;
namespace NFMsg {
class AckConnectWorldResult;
struct AckConnectWorldResultDefaultTypeInternal;
extern AckConnectWorldResultDefaultTypeInternal _AckConnectWorldResult_default_instance_;
class AckEventResult;
struct AckEventResultDefaultTypeInternal;
extern AckEventResultDefaultTypeInternal _AckEventResult_default_instance_;
class AckRoleLiteInfoList;
struct AckRoleLiteInfoListDefaultTypeInternal;
extern AckRoleLiteInfoListDefaultTypeInternal _AckRoleLiteInfoList_default_instance_;
class AckServerList;
struct AckServerListDefaultTypeInternal;
extern AckServerListDefaultTypeInternal _AckServerList_default_instance_;
class ReqAccountLogin;
struct ReqAccountLoginDefaultTypeInternal;
extern ReqAccountLoginDefaultTypeInternal _ReqAccountLogin_default_instance_;
class ReqAccountLogout;
struct ReqAccountLogoutDefaultTypeInternal;
extern ReqAccountLogoutDefaultTypeInternal _ReqAccountLogout_default_instance_;
class ReqConnectWorld;
struct ReqConnectWorldDefaultTypeInternal;
extern ReqConnectWorldDefaultTypeInternal _ReqConnectWorld_default_instance_;
class ReqCreateRole;
struct ReqCreateRoleDefaultTypeInternal;
extern ReqCreateRoleDefaultTypeInternal _ReqCreateRole_default_instance_;
class ReqDeleteRole;
struct ReqDeleteRoleDefaultTypeInternal;
extern ReqDeleteRoleDefaultTypeInternal _ReqDeleteRole_default_instance_;
class ReqKickFromWorld;
struct ReqKickFromWorldDefaultTypeInternal;
extern ReqKickFromWorldDefaultTypeInternal _ReqKickFromWorld_default_instance_;
class ReqRecoverRole;
struct ReqRecoverRoleDefaultTypeInternal;
extern ReqRecoverRoleDefaultTypeInternal _ReqRecoverRole_default_instance_;
class ReqRoleList;
struct ReqRoleListDefaultTypeInternal;
extern ReqRoleListDefaultTypeInternal _ReqRoleList_default_instance_;
class ReqSelectServer;
struct ReqSelectServerDefaultTypeInternal;
extern ReqSelectServerDefaultTypeInternal _ReqSelectServer_default_instance_;
class ReqServerList;
struct ReqServerListDefaultTypeInternal;
extern ReqServerListDefaultTypeInternal _ReqServerList_default_instance_;
class RoleDataPack;
struct RoleDataPackDefaultTypeInternal;
extern RoleDataPackDefaultTypeInternal _RoleDataPack_default_instance_;
class RoleLiteInfo;
struct RoleLiteInfoDefaultTypeInternal;
extern RoleLiteInfoDefaultTypeInternal _RoleLiteInfo_default_instance_;
class RoleOfflineNotify;
struct RoleOfflineNotifyDefaultTypeInternal;
extern RoleOfflineNotifyDefaultTypeInternal _RoleOfflineNotify_default_instance_;
class RoleOnlineNotify;
struct RoleOnlineNotifyDefaultTypeInternal;
extern RoleOnlineNotifyDefaultTypeInternal _RoleOnlineNotify_default_instance_;
class ServerHeartBeat;
struct ServerHeartBeatDefaultTypeInternal;
extern ServerHeartBeatDefaultTypeInternal _ServerHeartBeat_default_instance_;
class ServerInfo;
struct ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class ServerInfoReport;
struct ServerInfoReportDefaultTypeInternal;
extern ServerInfoReportDefaultTypeInternal _ServerInfoReport_default_instance_;
class ServerInfoReportList;
struct ServerInfoReportListDefaultTypeInternal;
extern ServerInfoReportListDefaultTypeInternal _ServerInfoReportList_default_instance_;
}  // namespace NFMsg
PROTOBUF_NAMESPACE_OPEN
template<> ::NFMsg::AckConnectWorldResult* Arena::CreateMaybeMessage<::NFMsg::AckConnectWorldResult>(Arena*);
template<> ::NFMsg::AckEventResult* Arena::CreateMaybeMessage<::NFMsg::AckEventResult>(Arena*);
template<> ::NFMsg::AckRoleLiteInfoList* Arena::CreateMaybeMessage<::NFMsg::AckRoleLiteInfoList>(Arena*);
template<> ::NFMsg::AckServerList* Arena::CreateMaybeMessage<::NFMsg::AckServerList>(Arena*);
template<> ::NFMsg::ReqAccountLogin* Arena::CreateMaybeMessage<::NFMsg::ReqAccountLogin>(Arena*);
template<> ::NFMsg::ReqAccountLogout* Arena::CreateMaybeMessage<::NFMsg::ReqAccountLogout>(Arena*);
template<> ::NFMsg::ReqConnectWorld* Arena::CreateMaybeMessage<::NFMsg::ReqConnectWorld>(Arena*);
template<> ::NFMsg::ReqCreateRole* Arena::CreateMaybeMessage<::NFMsg::ReqCreateRole>(Arena*);
template<> ::NFMsg::ReqDeleteRole* Arena::CreateMaybeMessage<::NFMsg::ReqDeleteRole>(Arena*);
template<> ::NFMsg::ReqKickFromWorld* Arena::CreateMaybeMessage<::NFMsg::ReqKickFromWorld>(Arena*);
template<> ::NFMsg::ReqRecoverRole* Arena::CreateMaybeMessage<::NFMsg::ReqRecoverRole>(Arena*);
template<> ::NFMsg::ReqRoleList* Arena::CreateMaybeMessage<::NFMsg::ReqRoleList>(Arena*);
template<> ::NFMsg::ReqSelectServer* Arena::CreateMaybeMessage<::NFMsg::ReqSelectServer>(Arena*);
template<> ::NFMsg::ReqServerList* Arena::CreateMaybeMessage<::NFMsg::ReqServerList>(Arena*);
template<> ::NFMsg::RoleDataPack* Arena::CreateMaybeMessage<::NFMsg::RoleDataPack>(Arena*);
template<> ::NFMsg::RoleLiteInfo* Arena::CreateMaybeMessage<::NFMsg::RoleLiteInfo>(Arena*);
template<> ::NFMsg::RoleOfflineNotify* Arena::CreateMaybeMessage<::NFMsg::RoleOfflineNotify>(Arena*);
template<> ::NFMsg::RoleOnlineNotify* Arena::CreateMaybeMessage<::NFMsg::RoleOnlineNotify>(Arena*);
template<> ::NFMsg::ServerHeartBeat* Arena::CreateMaybeMessage<::NFMsg::ServerHeartBeat>(Arena*);
template<> ::NFMsg::ServerInfo* Arena::CreateMaybeMessage<::NFMsg::ServerInfo>(Arena*);
template<> ::NFMsg::ServerInfoReport* Arena::CreateMaybeMessage<::NFMsg::ServerInfoReport>(Arena*);
template<> ::NFMsg::ServerInfoReportList* Arena::CreateMaybeMessage<::NFMsg::ServerInfoReportList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace NFMsg {

enum EServerState : int {
  EST_CRASH = 0,
  EST_NARMAL = 1,
  EST_BUSY = 2,
  EST_FIRE = 3,
  EST_MAINTEN = 4,
  EServerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EServerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EServerState_IsValid(int value);
constexpr EServerState EServerState_MIN = EST_CRASH;
constexpr EServerState EServerState_MAX = EST_MAINTEN;
constexpr int EServerState_ARRAYSIZE = EServerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EServerState_descriptor();
template<typename T>
inline const std::string& EServerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EServerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EServerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EServerState_descriptor(), enum_t_value);
}
inline bool EServerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EServerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EServerState>(
    EServerState_descriptor(), name, value);
}
enum ELoginMode : int {
  ELM_LOGIN = 0,
  ELM_REGISTER = 1,
  ELM_AUTO_REGISTER_LOGIN = 2,
  ELoginMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ELoginMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ELoginMode_IsValid(int value);
constexpr ELoginMode ELoginMode_MIN = ELM_LOGIN;
constexpr ELoginMode ELoginMode_MAX = ELM_AUTO_REGISTER_LOGIN;
constexpr int ELoginMode_ARRAYSIZE = ELoginMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELoginMode_descriptor();
template<typename T>
inline const std::string& ELoginMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELoginMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELoginMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELoginMode_descriptor(), enum_t_value);
}
inline bool ELoginMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELoginMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELoginMode>(
    ELoginMode_descriptor(), name, value);
}
enum ReqServerListType : int {
  RSLT_WORLD_SERVER = 0,
  RSLT_GAMES_ERVER = 1,
  ReqServerListType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ReqServerListType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ReqServerListType_IsValid(int value);
constexpr ReqServerListType ReqServerListType_MIN = RSLT_WORLD_SERVER;
constexpr ReqServerListType ReqServerListType_MAX = RSLT_GAMES_ERVER;
constexpr int ReqServerListType_ARRAYSIZE = ReqServerListType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReqServerListType_descriptor();
template<typename T>
inline const std::string& ReqServerListType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReqServerListType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReqServerListType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReqServerListType_descriptor(), enum_t_value);
}
inline bool ReqServerListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReqServerListType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReqServerListType>(
    ReqServerListType_descriptor(), name, value);
}
// ===================================================================

class ServerInfoReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ServerInfoReport) */ {
 public:
  inline ServerInfoReport() : ServerInfoReport(nullptr) {}
  ~ServerInfoReport() override;
  explicit PROTOBUF_CONSTEXPR ServerInfoReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfoReport(const ServerInfoReport& from);
  ServerInfoReport(ServerInfoReport&& from) noexcept
    : ServerInfoReport() {
    *this = ::std::move(from);
  }

  inline ServerInfoReport& operator=(const ServerInfoReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfoReport& operator=(ServerInfoReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfoReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfoReport* internal_default_instance() {
    return reinterpret_cast<const ServerInfoReport*>(
               &_ServerInfoReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServerInfoReport& a, ServerInfoReport& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfoReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfoReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfoReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerInfoReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfoReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerInfoReport& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfoReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ServerInfoReport";
  }
  protected:
  explicit ServerInfoReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerNameFieldNumber = 2,
    kServerIpFieldNumber = 3,
    kServerIdFieldNumber = 1,
    kServerPortFieldNumber = 4,
    kServerMaxOnlineFieldNumber = 5,
    kServerCurCountFieldNumber = 6,
    kServerStateFieldNumber = 7,
    kServerTypeFieldNumber = 8,
  };
  // bytes server_name = 2;
  void clear_server_name();
  const std::string& server_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_name();
  PROTOBUF_NODISCARD std::string* release_server_name();
  void set_allocated_server_name(std::string* server_name);
  private:
  const std::string& _internal_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_name(const std::string& value);
  std::string* _internal_mutable_server_name();
  public:

  // bytes server_ip = 3;
  void clear_server_ip();
  const std::string& server_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_ip();
  PROTOBUF_NODISCARD std::string* release_server_ip();
  void set_allocated_server_ip(std::string* server_ip);
  private:
  const std::string& _internal_server_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_ip(const std::string& value);
  std::string* _internal_mutable_server_ip();
  public:

  // int32 server_id = 1;
  void clear_server_id();
  int32_t server_id() const;
  void set_server_id(int32_t value);
  private:
  int32_t _internal_server_id() const;
  void _internal_set_server_id(int32_t value);
  public:

  // int32 server_port = 4;
  void clear_server_port();
  int32_t server_port() const;
  void set_server_port(int32_t value);
  private:
  int32_t _internal_server_port() const;
  void _internal_set_server_port(int32_t value);
  public:

  // int32 server_max_online = 5;
  void clear_server_max_online();
  int32_t server_max_online() const;
  void set_server_max_online(int32_t value);
  private:
  int32_t _internal_server_max_online() const;
  void _internal_set_server_max_online(int32_t value);
  public:

  // int32 server_cur_count = 6;
  void clear_server_cur_count();
  int32_t server_cur_count() const;
  void set_server_cur_count(int32_t value);
  private:
  int32_t _internal_server_cur_count() const;
  void _internal_set_server_cur_count(int32_t value);
  public:

  // .NFMsg.EServerState server_state = 7;
  void clear_server_state();
  ::NFMsg::EServerState server_state() const;
  void set_server_state(::NFMsg::EServerState value);
  private:
  ::NFMsg::EServerState _internal_server_state() const;
  void _internal_set_server_state(::NFMsg::EServerState value);
  public:

  // int32 server_type = 8;
  void clear_server_type();
  int32_t server_type() const;
  void set_server_type(int32_t value);
  private:
  int32_t _internal_server_type() const;
  void _internal_set_server_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ServerInfoReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_ip_;
  int32_t server_id_;
  int32_t server_port_;
  int32_t server_max_online_;
  int32_t server_cur_count_;
  int server_state_;
  int32_t server_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ServerInfoReportList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ServerInfoReportList) */ {
 public:
  inline ServerInfoReportList() : ServerInfoReportList(nullptr) {}
  ~ServerInfoReportList() override;
  explicit PROTOBUF_CONSTEXPR ServerInfoReportList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfoReportList(const ServerInfoReportList& from);
  ServerInfoReportList(ServerInfoReportList&& from) noexcept
    : ServerInfoReportList() {
    *this = ::std::move(from);
  }

  inline ServerInfoReportList& operator=(const ServerInfoReportList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfoReportList& operator=(ServerInfoReportList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfoReportList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfoReportList* internal_default_instance() {
    return reinterpret_cast<const ServerInfoReportList*>(
               &_ServerInfoReportList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerInfoReportList& a, ServerInfoReportList& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfoReportList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfoReportList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfoReportList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerInfoReportList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfoReportList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerInfoReportList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfoReportList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ServerInfoReportList";
  }
  protected:
  explicit ServerInfoReportList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerListFieldNumber = 1,
  };
  // repeated .NFMsg.ServerInfoReport server_list = 1;
  int server_list_size() const;
  private:
  int _internal_server_list_size() const;
  public:
  void clear_server_list();
  ::NFMsg::ServerInfoReport* mutable_server_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfoReport >*
      mutable_server_list();
  private:
  const ::NFMsg::ServerInfoReport& _internal_server_list(int index) const;
  ::NFMsg::ServerInfoReport* _internal_add_server_list();
  public:
  const ::NFMsg::ServerInfoReport& server_list(int index) const;
  ::NFMsg::ServerInfoReport* add_server_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfoReport >&
      server_list() const;

  // @@protoc_insertion_point(class_scope:NFMsg.ServerInfoReportList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfoReport > server_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class AckEventResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckEventResult) */ {
 public:
  inline AckEventResult() : AckEventResult(nullptr) {}
  ~AckEventResult() override;
  explicit PROTOBUF_CONSTEXPR AckEventResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckEventResult(const AckEventResult& from);
  AckEventResult(AckEventResult&& from) noexcept
    : AckEventResult() {
    *this = ::std::move(from);
  }

  inline AckEventResult& operator=(const AckEventResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckEventResult& operator=(AckEventResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckEventResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckEventResult* internal_default_instance() {
    return reinterpret_cast<const AckEventResult*>(
               &_AckEventResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AckEventResult& a, AckEventResult& b) {
    a.Swap(&b);
  }
  inline void Swap(AckEventResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckEventResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckEventResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckEventResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckEventResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckEventResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckEventResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.AckEventResult";
  }
  protected:
  explicit AckEventResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventObjectFieldNumber = 2,
    kEventClientFieldNumber = 3,
    kEventCodeFieldNumber = 1,
  };
  // .NFMsg.Ident event_object = 2;
  bool has_event_object() const;
  private:
  bool _internal_has_event_object() const;
  public:
  void clear_event_object();
  const ::NFMsg::Ident& event_object() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_event_object();
  ::NFMsg::Ident* mutable_event_object();
  void set_allocated_event_object(::NFMsg::Ident* event_object);
  private:
  const ::NFMsg::Ident& _internal_event_object() const;
  ::NFMsg::Ident* _internal_mutable_event_object();
  public:
  void unsafe_arena_set_allocated_event_object(
      ::NFMsg::Ident* event_object);
  ::NFMsg::Ident* unsafe_arena_release_event_object();

  // .NFMsg.Ident event_client = 3;
  bool has_event_client() const;
  private:
  bool _internal_has_event_client() const;
  public:
  void clear_event_client();
  const ::NFMsg::Ident& event_client() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_event_client();
  ::NFMsg::Ident* mutable_event_client();
  void set_allocated_event_client(::NFMsg::Ident* event_client);
  private:
  const ::NFMsg::Ident& _internal_event_client() const;
  ::NFMsg::Ident* _internal_mutable_event_client();
  public:
  void unsafe_arena_set_allocated_event_client(
      ::NFMsg::Ident* event_client);
  ::NFMsg::Ident* unsafe_arena_release_event_client();

  // .NFMsg.EGameEventCode event_code = 1;
  void clear_event_code();
  ::NFMsg::EGameEventCode event_code() const;
  void set_event_code(::NFMsg::EGameEventCode value);
  private:
  ::NFMsg::EGameEventCode _internal_event_code() const;
  void _internal_set_event_code(::NFMsg::EGameEventCode value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.AckEventResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::NFMsg::Ident* event_object_;
  ::NFMsg::Ident* event_client_;
  int event_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqAccountLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAccountLogin) */ {
 public:
  inline ReqAccountLogin() : ReqAccountLogin(nullptr) {}
  ~ReqAccountLogin() override;
  explicit PROTOBUF_CONSTEXPR ReqAccountLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqAccountLogin(const ReqAccountLogin& from);
  ReqAccountLogin(ReqAccountLogin&& from) noexcept
    : ReqAccountLogin() {
    *this = ::std::move(from);
  }

  inline ReqAccountLogin& operator=(const ReqAccountLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqAccountLogin& operator=(ReqAccountLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqAccountLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqAccountLogin* internal_default_instance() {
    return reinterpret_cast<const ReqAccountLogin*>(
               &_ReqAccountLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReqAccountLogin& a, ReqAccountLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqAccountLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqAccountLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqAccountLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqAccountLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqAccountLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqAccountLogin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAccountLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqAccountLogin";
  }
  protected:
  explicit ReqAccountLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kSecurityCodeFieldNumber = 4,
    kSignBuffFieldNumber = 5,
    kDeviceInfoFieldNumber = 10,
    kExtraInfoFieldNumber = 11,
    kClientVersionFieldNumber = 6,
    kLoginModeFieldNumber = 7,
    kClientMACFieldNumber = 9,
    kClientIPFieldNumber = 8,
    kPlatformTypeFieldNumber = 12,
  };
  // bytes account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // bytes security_code = 4;
  void clear_security_code();
  const std::string& security_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_security_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_security_code();
  PROTOBUF_NODISCARD std::string* release_security_code();
  void set_allocated_security_code(std::string* security_code);
  private:
  const std::string& _internal_security_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_security_code(const std::string& value);
  std::string* _internal_mutable_security_code();
  public:

  // bytes signBuff = 5;
  void clear_signbuff();
  const std::string& signbuff() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signbuff(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signbuff();
  PROTOBUF_NODISCARD std::string* release_signbuff();
  void set_allocated_signbuff(std::string* signbuff);
  private:
  const std::string& _internal_signbuff() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signbuff(const std::string& value);
  std::string* _internal_mutable_signbuff();
  public:

  // bytes device_info = 10;
  void clear_device_info();
  const std::string& device_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_info();
  PROTOBUF_NODISCARD std::string* release_device_info();
  void set_allocated_device_info(std::string* device_info);
  private:
  const std::string& _internal_device_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_info(const std::string& value);
  std::string* _internal_mutable_device_info();
  public:

  // bytes extra_info = 11;
  void clear_extra_info();
  const std::string& extra_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra_info();
  PROTOBUF_NODISCARD std::string* release_extra_info();
  void set_allocated_extra_info(std::string* extra_info);
  private:
  const std::string& _internal_extra_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_info(const std::string& value);
  std::string* _internal_mutable_extra_info();
  public:

  // int32 clientVersion = 6;
  void clear_clientversion();
  int32_t clientversion() const;
  void set_clientversion(int32_t value);
  private:
  int32_t _internal_clientversion() const;
  void _internal_set_clientversion(int32_t value);
  public:

  // .NFMsg.ELoginMode loginMode = 7;
  void clear_loginmode();
  ::NFMsg::ELoginMode loginmode() const;
  void set_loginmode(::NFMsg::ELoginMode value);
  private:
  ::NFMsg::ELoginMode _internal_loginmode() const;
  void _internal_set_loginmode(::NFMsg::ELoginMode value);
  public:

  // int64 clientMAC = 9;
  void clear_clientmac();
  int64_t clientmac() const;
  void set_clientmac(int64_t value);
  private:
  int64_t _internal_clientmac() const;
  void _internal_set_clientmac(int64_t value);
  public:

  // int32 clientIP = 8;
  void clear_clientip();
  int32_t clientip() const;
  void set_clientip(int32_t value);
  private:
  int32_t _internal_clientip() const;
  void _internal_set_clientip(int32_t value);
  public:

  // int32 platform_type = 12;
  void clear_platform_type();
  int32_t platform_type() const;
  void set_platform_type(int32_t value);
  private:
  int32_t _internal_platform_type() const;
  void _internal_set_platform_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAccountLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr security_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signbuff_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_info_;
  int32_t clientversion_;
  int loginmode_;
  int64_t clientmac_;
  int32_t clientip_;
  int32_t platform_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqAccountLogout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAccountLogout) */ {
 public:
  inline ReqAccountLogout() : ReqAccountLogout(nullptr) {}
  ~ReqAccountLogout() override;
  explicit PROTOBUF_CONSTEXPR ReqAccountLogout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqAccountLogout(const ReqAccountLogout& from);
  ReqAccountLogout(ReqAccountLogout&& from) noexcept
    : ReqAccountLogout() {
    *this = ::std::move(from);
  }

  inline ReqAccountLogout& operator=(const ReqAccountLogout& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqAccountLogout& operator=(ReqAccountLogout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqAccountLogout& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqAccountLogout* internal_default_instance() {
    return reinterpret_cast<const ReqAccountLogout*>(
               &_ReqAccountLogout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReqAccountLogout& a, ReqAccountLogout& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqAccountLogout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqAccountLogout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqAccountLogout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqAccountLogout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqAccountLogout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqAccountLogout& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAccountLogout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqAccountLogout";
  }
  protected:
  explicit ReqAccountLogout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kExtraInfoFieldNumber = 3,
  };
  // bytes account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes extra_info = 3;
  void clear_extra_info();
  const std::string& extra_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra_info();
  PROTOBUF_NODISCARD std::string* release_extra_info();
  void set_allocated_extra_info(std::string* extra_info);
  private:
  const std::string& _internal_extra_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_info(const std::string& value);
  std::string* _internal_mutable_extra_info();
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAccountLogout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {}
  ~ServerInfo() override;
  explicit PROTOBUF_CONSTEXPR ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfo(const ServerInfo& from);
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ServerInfo";
  }
  protected:
  explicit ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kServerIdFieldNumber = 1,
    kWaitCountFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 server_id = 1;
  void clear_server_id();
  int32_t server_id() const;
  void set_server_id(int32_t value);
  private:
  int32_t _internal_server_id() const;
  void _internal_set_server_id(int32_t value);
  public:

  // int32 wait_count = 3;
  void clear_wait_count();
  int32_t wait_count() const;
  void set_wait_count(int32_t value);
  private:
  int32_t _internal_wait_count() const;
  void _internal_set_wait_count(int32_t value);
  public:

  // .NFMsg.EServerState status = 4;
  void clear_status();
  ::NFMsg::EServerState status() const;
  void set_status(::NFMsg::EServerState value);
  private:
  ::NFMsg::EServerState _internal_status() const;
  void _internal_set_status(::NFMsg::EServerState value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t server_id_;
  int32_t wait_count_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqServerList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqServerList) */ {
 public:
  inline ReqServerList() : ReqServerList(nullptr) {}
  ~ReqServerList() override;
  explicit PROTOBUF_CONSTEXPR ReqServerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqServerList(const ReqServerList& from);
  ReqServerList(ReqServerList&& from) noexcept
    : ReqServerList() {
    *this = ::std::move(from);
  }

  inline ReqServerList& operator=(const ReqServerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqServerList& operator=(ReqServerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqServerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqServerList* internal_default_instance() {
    return reinterpret_cast<const ReqServerList*>(
               &_ReqServerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReqServerList& a, ReqServerList& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqServerList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqServerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqServerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqServerList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqServerList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqServerList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqServerList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqServerList";
  }
  protected:
  explicit ReqServerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .NFMsg.ReqServerListType type = 1;
  void clear_type();
  ::NFMsg::ReqServerListType type() const;
  void set_type(::NFMsg::ReqServerListType value);
  private:
  ::NFMsg::ReqServerListType _internal_type() const;
  void _internal_set_type(::NFMsg::ReqServerListType value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqServerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class AckServerList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckServerList) */ {
 public:
  inline AckServerList() : AckServerList(nullptr) {}
  ~AckServerList() override;
  explicit PROTOBUF_CONSTEXPR AckServerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckServerList(const AckServerList& from);
  AckServerList(AckServerList&& from) noexcept
    : AckServerList() {
    *this = ::std::move(from);
  }

  inline AckServerList& operator=(const AckServerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckServerList& operator=(AckServerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckServerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckServerList* internal_default_instance() {
    return reinterpret_cast<const AckServerList*>(
               &_AckServerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AckServerList& a, AckServerList& b) {
    a.Swap(&b);
  }
  inline void Swap(AckServerList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckServerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckServerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckServerList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckServerList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckServerList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckServerList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.AckServerList";
  }
  protected:
  explicit AckServerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .NFMsg.ServerInfo info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::NFMsg::ServerInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfo >*
      mutable_info();
  private:
  const ::NFMsg::ServerInfo& _internal_info(int index) const;
  ::NFMsg::ServerInfo* _internal_add_info();
  public:
  const ::NFMsg::ServerInfo& info(int index) const;
  ::NFMsg::ServerInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfo >&
      info() const;

  // .NFMsg.ReqServerListType type = 1;
  void clear_type();
  ::NFMsg::ReqServerListType type() const;
  void set_type(::NFMsg::ReqServerListType value);
  private:
  ::NFMsg::ReqServerListType _internal_type() const;
  void _internal_set_type(::NFMsg::ReqServerListType value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.AckServerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfo > info_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqConnectWorld final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqConnectWorld) */ {
 public:
  inline ReqConnectWorld() : ReqConnectWorld(nullptr) {}
  ~ReqConnectWorld() override;
  explicit PROTOBUF_CONSTEXPR ReqConnectWorld(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqConnectWorld(const ReqConnectWorld& from);
  ReqConnectWorld(ReqConnectWorld&& from) noexcept
    : ReqConnectWorld() {
    *this = ::std::move(from);
  }

  inline ReqConnectWorld& operator=(const ReqConnectWorld& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqConnectWorld& operator=(ReqConnectWorld&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqConnectWorld& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqConnectWorld* internal_default_instance() {
    return reinterpret_cast<const ReqConnectWorld*>(
               &_ReqConnectWorld_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReqConnectWorld& a, ReqConnectWorld& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqConnectWorld* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqConnectWorld* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqConnectWorld* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqConnectWorld>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqConnectWorld& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqConnectWorld& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqConnectWorld* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqConnectWorld";
  }
  protected:
  explicit ReqConnectWorld(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kSenderFieldNumber = 3,
    kWorldIdFieldNumber = 1,
    kLoginIdFieldNumber = 4,
  };
  // bytes account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // .NFMsg.Ident sender = 3;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::NFMsg::Ident& sender() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_sender();
  ::NFMsg::Ident* mutable_sender();
  void set_allocated_sender(::NFMsg::Ident* sender);
  private:
  const ::NFMsg::Ident& _internal_sender() const;
  ::NFMsg::Ident* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::NFMsg::Ident* sender);
  ::NFMsg::Ident* unsafe_arena_release_sender();

  // int32 world_id = 1;
  void clear_world_id();
  int32_t world_id() const;
  void set_world_id(int32_t value);
  private:
  int32_t _internal_world_id() const;
  void _internal_set_world_id(int32_t value);
  public:

  // int32 login_id = 4;
  void clear_login_id();
  int32_t login_id() const;
  void set_login_id(int32_t value);
  private:
  int32_t _internal_login_id() const;
  void _internal_set_login_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqConnectWorld)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::NFMsg::Ident* sender_;
  int32_t world_id_;
  int32_t login_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class AckConnectWorldResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckConnectWorldResult) */ {
 public:
  inline AckConnectWorldResult() : AckConnectWorldResult(nullptr) {}
  ~AckConnectWorldResult() override;
  explicit PROTOBUF_CONSTEXPR AckConnectWorldResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckConnectWorldResult(const AckConnectWorldResult& from);
  AckConnectWorldResult(AckConnectWorldResult&& from) noexcept
    : AckConnectWorldResult() {
    *this = ::std::move(from);
  }

  inline AckConnectWorldResult& operator=(const AckConnectWorldResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckConnectWorldResult& operator=(AckConnectWorldResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckConnectWorldResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckConnectWorldResult* internal_default_instance() {
    return reinterpret_cast<const AckConnectWorldResult*>(
               &_AckConnectWorldResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AckConnectWorldResult& a, AckConnectWorldResult& b) {
    a.Swap(&b);
  }
  inline void Swap(AckConnectWorldResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckConnectWorldResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckConnectWorldResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckConnectWorldResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckConnectWorldResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckConnectWorldResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckConnectWorldResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.AckConnectWorldResult";
  }
  protected:
  explicit AckConnectWorldResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 4,
    kWorldIpFieldNumber = 5,
    kWorldKeyFieldNumber = 7,
    kSenderFieldNumber = 2,
    kWorldIdFieldNumber = 1,
    kLoginIdFieldNumber = 3,
    kWorldPortFieldNumber = 6,
  };
  // bytes account = 4;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes world_ip = 5;
  void clear_world_ip();
  const std::string& world_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_world_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_world_ip();
  PROTOBUF_NODISCARD std::string* release_world_ip();
  void set_allocated_world_ip(std::string* world_ip);
  private:
  const std::string& _internal_world_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_world_ip(const std::string& value);
  std::string* _internal_mutable_world_ip();
  public:

  // bytes world_key = 7;
  void clear_world_key();
  const std::string& world_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_world_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_world_key();
  PROTOBUF_NODISCARD std::string* release_world_key();
  void set_allocated_world_key(std::string* world_key);
  private:
  const std::string& _internal_world_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_world_key(const std::string& value);
  std::string* _internal_mutable_world_key();
  public:

  // .NFMsg.Ident sender = 2;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::NFMsg::Ident& sender() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_sender();
  ::NFMsg::Ident* mutable_sender();
  void set_allocated_sender(::NFMsg::Ident* sender);
  private:
  const ::NFMsg::Ident& _internal_sender() const;
  ::NFMsg::Ident* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::NFMsg::Ident* sender);
  ::NFMsg::Ident* unsafe_arena_release_sender();

  // int32 world_id = 1;
  void clear_world_id();
  int32_t world_id() const;
  void set_world_id(int32_t value);
  private:
  int32_t _internal_world_id() const;
  void _internal_set_world_id(int32_t value);
  public:

  // int32 login_id = 3;
  void clear_login_id();
  int32_t login_id() const;
  void set_login_id(int32_t value);
  private:
  int32_t _internal_login_id() const;
  void _internal_set_login_id(int32_t value);
  public:

  // int32 world_port = 6;
  void clear_world_port();
  int32_t world_port() const;
  void set_world_port(int32_t value);
  private:
  int32_t _internal_world_port() const;
  void _internal_set_world_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.AckConnectWorldResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr world_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr world_key_;
  ::NFMsg::Ident* sender_;
  int32_t world_id_;
  int32_t login_id_;
  int32_t world_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqSelectServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqSelectServer) */ {
 public:
  inline ReqSelectServer() : ReqSelectServer(nullptr) {}
  ~ReqSelectServer() override;
  explicit PROTOBUF_CONSTEXPR ReqSelectServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSelectServer(const ReqSelectServer& from);
  ReqSelectServer(ReqSelectServer&& from) noexcept
    : ReqSelectServer() {
    *this = ::std::move(from);
  }

  inline ReqSelectServer& operator=(const ReqSelectServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSelectServer& operator=(ReqSelectServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSelectServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSelectServer* internal_default_instance() {
    return reinterpret_cast<const ReqSelectServer*>(
               &_ReqSelectServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReqSelectServer& a, ReqSelectServer& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSelectServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSelectServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSelectServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSelectServer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSelectServer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSelectServer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSelectServer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqSelectServer";
  }
  protected:
  explicit ReqSelectServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldIdFieldNumber = 1,
  };
  // int32 world_id = 1;
  void clear_world_id();
  int32_t world_id() const;
  void set_world_id(int32_t value);
  private:
  int32_t _internal_world_id() const;
  void _internal_set_world_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqSelectServer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t world_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqKickFromWorld final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqKickFromWorld) */ {
 public:
  inline ReqKickFromWorld() : ReqKickFromWorld(nullptr) {}
  ~ReqKickFromWorld() override;
  explicit PROTOBUF_CONSTEXPR ReqKickFromWorld(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqKickFromWorld(const ReqKickFromWorld& from);
  ReqKickFromWorld(ReqKickFromWorld&& from) noexcept
    : ReqKickFromWorld() {
    *this = ::std::move(from);
  }

  inline ReqKickFromWorld& operator=(const ReqKickFromWorld& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqKickFromWorld& operator=(ReqKickFromWorld&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqKickFromWorld& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqKickFromWorld* internal_default_instance() {
    return reinterpret_cast<const ReqKickFromWorld*>(
               &_ReqKickFromWorld_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ReqKickFromWorld& a, ReqKickFromWorld& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqKickFromWorld* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqKickFromWorld* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqKickFromWorld* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqKickFromWorld>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqKickFromWorld& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqKickFromWorld& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqKickFromWorld* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqKickFromWorld";
  }
  protected:
  explicit ReqKickFromWorld(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kWorldIdFieldNumber = 1,
  };
  // bytes account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // int32 world_id = 1;
  void clear_world_id();
  int32_t world_id() const;
  void set_world_id(int32_t value);
  private:
  int32_t _internal_world_id() const;
  void _internal_set_world_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqKickFromWorld)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  int32_t world_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqRoleList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqRoleList) */ {
 public:
  inline ReqRoleList() : ReqRoleList(nullptr) {}
  ~ReqRoleList() override;
  explicit PROTOBUF_CONSTEXPR ReqRoleList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoleList(const ReqRoleList& from);
  ReqRoleList(ReqRoleList&& from) noexcept
    : ReqRoleList() {
    *this = ::std::move(from);
  }

  inline ReqRoleList& operator=(const ReqRoleList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoleList& operator=(ReqRoleList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoleList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoleList* internal_default_instance() {
    return reinterpret_cast<const ReqRoleList*>(
               &_ReqRoleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ReqRoleList& a, ReqRoleList& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoleList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoleList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoleList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoleList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRoleList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqRoleList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRoleList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqRoleList";
  }
  protected:
  explicit ReqRoleList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kGameIdFieldNumber = 1,
  };
  // bytes account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // int32 game_id = 1;
  void clear_game_id();
  int32_t game_id() const;
  void set_game_id(int32_t value);
  private:
  int32_t _internal_game_id() const;
  void _internal_set_game_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqRoleList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  int32_t game_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class RoleLiteInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.RoleLiteInfo) */ {
 public:
  inline RoleLiteInfo() : RoleLiteInfo(nullptr) {}
  ~RoleLiteInfo() override;
  explicit PROTOBUF_CONSTEXPR RoleLiteInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleLiteInfo(const RoleLiteInfo& from);
  RoleLiteInfo(RoleLiteInfo&& from) noexcept
    : RoleLiteInfo() {
    *this = ::std::move(from);
  }

  inline RoleLiteInfo& operator=(const RoleLiteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleLiteInfo& operator=(RoleLiteInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleLiteInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleLiteInfo* internal_default_instance() {
    return reinterpret_cast<const RoleLiteInfo*>(
               &_RoleLiteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RoleLiteInfo& a, RoleLiteInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleLiteInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleLiteInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleLiteInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleLiteInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleLiteInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleLiteInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleLiteInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.RoleLiteInfo";
  }
  protected:
  explicit RoleLiteInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoobNameFieldNumber = 5,
    kViewRecordFieldNumber = 12,
    kIdFieldNumber = 1,
    kCareerFieldNumber = 2,
    kSexFieldNumber = 3,
    kRaceFieldNumber = 4,
    kGameIdFieldNumber = 6,
    kRoleLevelFieldNumber = 7,
    kDeleteTimeFieldNumber = 8,
    kRegTimeFieldNumber = 9,
    kLastOfflineTimeFieldNumber = 10,
    kLastOfflineIpFieldNumber = 11,
  };
  // bytes noob_name = 5;
  void clear_noob_name();
  const std::string& noob_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_noob_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_noob_name();
  PROTOBUF_NODISCARD std::string* release_noob_name();
  void set_allocated_noob_name(std::string* noob_name);
  private:
  const std::string& _internal_noob_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_noob_name(const std::string& value);
  std::string* _internal_mutable_noob_name();
  public:

  // bytes view_record = 12;
  void clear_view_record();
  const std::string& view_record() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_record(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_record();
  PROTOBUF_NODISCARD std::string* release_view_record();
  void set_allocated_view_record(std::string* view_record);
  private:
  const std::string& _internal_view_record() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_record(const std::string& value);
  std::string* _internal_mutable_view_record();
  public:

  // .NFMsg.Ident id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::NFMsg::Ident& id() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_id();
  ::NFMsg::Ident* mutable_id();
  void set_allocated_id(::NFMsg::Ident* id);
  private:
  const ::NFMsg::Ident& _internal_id() const;
  ::NFMsg::Ident* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::NFMsg::Ident* id);
  ::NFMsg::Ident* unsafe_arena_release_id();

  // int32 career = 2;
  void clear_career();
  int32_t career() const;
  void set_career(int32_t value);
  private:
  int32_t _internal_career() const;
  void _internal_set_career(int32_t value);
  public:

  // int32 sex = 3;
  void clear_sex();
  int32_t sex() const;
  void set_sex(int32_t value);
  private:
  int32_t _internal_sex() const;
  void _internal_set_sex(int32_t value);
  public:

  // int32 race = 4;
  void clear_race();
  int32_t race() const;
  void set_race(int32_t value);
  private:
  int32_t _internal_race() const;
  void _internal_set_race(int32_t value);
  public:

  // int32 game_id = 6;
  void clear_game_id();
  int32_t game_id() const;
  void set_game_id(int32_t value);
  private:
  int32_t _internal_game_id() const;
  void _internal_set_game_id(int32_t value);
  public:

  // int32 role_level = 7;
  void clear_role_level();
  int32_t role_level() const;
  void set_role_level(int32_t value);
  private:
  int32_t _internal_role_level() const;
  void _internal_set_role_level(int32_t value);
  public:

  // int32 delete_time = 8;
  void clear_delete_time();
  int32_t delete_time() const;
  void set_delete_time(int32_t value);
  private:
  int32_t _internal_delete_time() const;
  void _internal_set_delete_time(int32_t value);
  public:

  // int32 reg_time = 9;
  void clear_reg_time();
  int32_t reg_time() const;
  void set_reg_time(int32_t value);
  private:
  int32_t _internal_reg_time() const;
  void _internal_set_reg_time(int32_t value);
  public:

  // int32 last_offline_time = 10;
  void clear_last_offline_time();
  int32_t last_offline_time() const;
  void set_last_offline_time(int32_t value);
  private:
  int32_t _internal_last_offline_time() const;
  void _internal_set_last_offline_time(int32_t value);
  public:

  // int32 last_offline_ip = 11;
  void clear_last_offline_ip();
  int32_t last_offline_ip() const;
  void set_last_offline_ip(int32_t value);
  private:
  int32_t _internal_last_offline_ip() const;
  void _internal_set_last_offline_ip(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.RoleLiteInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr noob_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_record_;
  ::NFMsg::Ident* id_;
  int32_t career_;
  int32_t sex_;
  int32_t race_;
  int32_t game_id_;
  int32_t role_level_;
  int32_t delete_time_;
  int32_t reg_time_;
  int32_t last_offline_time_;
  int32_t last_offline_ip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class AckRoleLiteInfoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckRoleLiteInfoList) */ {
 public:
  inline AckRoleLiteInfoList() : AckRoleLiteInfoList(nullptr) {}
  ~AckRoleLiteInfoList() override;
  explicit PROTOBUF_CONSTEXPR AckRoleLiteInfoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckRoleLiteInfoList(const AckRoleLiteInfoList& from);
  AckRoleLiteInfoList(AckRoleLiteInfoList&& from) noexcept
    : AckRoleLiteInfoList() {
    *this = ::std::move(from);
  }

  inline AckRoleLiteInfoList& operator=(const AckRoleLiteInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckRoleLiteInfoList& operator=(AckRoleLiteInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckRoleLiteInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckRoleLiteInfoList* internal_default_instance() {
    return reinterpret_cast<const AckRoleLiteInfoList*>(
               &_AckRoleLiteInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AckRoleLiteInfoList& a, AckRoleLiteInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(AckRoleLiteInfoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckRoleLiteInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckRoleLiteInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckRoleLiteInfoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckRoleLiteInfoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckRoleLiteInfoList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckRoleLiteInfoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.AckRoleLiteInfoList";
  }
  protected:
  explicit AckRoleLiteInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharDataFieldNumber = 1,
    kAccountFieldNumber = 2,
  };
  // repeated .NFMsg.RoleLiteInfo char_data = 1;
  int char_data_size() const;
  private:
  int _internal_char_data_size() const;
  public:
  void clear_char_data();
  ::NFMsg::RoleLiteInfo* mutable_char_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::RoleLiteInfo >*
      mutable_char_data();
  private:
  const ::NFMsg::RoleLiteInfo& _internal_char_data(int index) const;
  ::NFMsg::RoleLiteInfo* _internal_add_char_data();
  public:
  const ::NFMsg::RoleLiteInfo& char_data(int index) const;
  ::NFMsg::RoleLiteInfo* add_char_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::RoleLiteInfo >&
      char_data() const;

  // bytes account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.AckRoleLiteInfoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::RoleLiteInfo > char_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqCreateRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqCreateRole) */ {
 public:
  inline ReqCreateRole() : ReqCreateRole(nullptr) {}
  ~ReqCreateRole() override;
  explicit PROTOBUF_CONSTEXPR ReqCreateRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqCreateRole(const ReqCreateRole& from);
  ReqCreateRole(ReqCreateRole&& from) noexcept
    : ReqCreateRole() {
    *this = ::std::move(from);
  }

  inline ReqCreateRole& operator=(const ReqCreateRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqCreateRole& operator=(ReqCreateRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqCreateRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqCreateRole* internal_default_instance() {
    return reinterpret_cast<const ReqCreateRole*>(
               &_ReqCreateRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReqCreateRole& a, ReqCreateRole& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqCreateRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqCreateRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqCreateRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqCreateRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqCreateRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqCreateRole& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqCreateRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqCreateRole";
  }
  protected:
  explicit ReqCreateRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kNoobNameFieldNumber = 5,
    kCareerFieldNumber = 2,
    kSexFieldNumber = 3,
    kRaceFieldNumber = 4,
  };
  // bytes account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes noob_name = 5;
  void clear_noob_name();
  const std::string& noob_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_noob_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_noob_name();
  PROTOBUF_NODISCARD std::string* release_noob_name();
  void set_allocated_noob_name(std::string* noob_name);
  private:
  const std::string& _internal_noob_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_noob_name(const std::string& value);
  std::string* _internal_mutable_noob_name();
  public:

  // int32 career = 2;
  void clear_career();
  int32_t career() const;
  void set_career(int32_t value);
  private:
  int32_t _internal_career() const;
  void _internal_set_career(int32_t value);
  public:

  // int32 sex = 3;
  void clear_sex();
  int32_t sex() const;
  void set_sex(int32_t value);
  private:
  int32_t _internal_sex() const;
  void _internal_set_sex(int32_t value);
  public:

  // int32 race = 4;
  void clear_race();
  int32_t race() const;
  void set_race(int32_t value);
  private:
  int32_t _internal_race() const;
  void _internal_set_race(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqCreateRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr noob_name_;
  int32_t career_;
  int32_t sex_;
  int32_t race_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqDeleteRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqDeleteRole) */ {
 public:
  inline ReqDeleteRole() : ReqDeleteRole(nullptr) {}
  ~ReqDeleteRole() override;
  explicit PROTOBUF_CONSTEXPR ReqDeleteRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqDeleteRole(const ReqDeleteRole& from);
  ReqDeleteRole(ReqDeleteRole&& from) noexcept
    : ReqDeleteRole() {
    *this = ::std::move(from);
  }

  inline ReqDeleteRole& operator=(const ReqDeleteRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqDeleteRole& operator=(ReqDeleteRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqDeleteRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqDeleteRole* internal_default_instance() {
    return reinterpret_cast<const ReqDeleteRole*>(
               &_ReqDeleteRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ReqDeleteRole& a, ReqDeleteRole& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqDeleteRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqDeleteRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqDeleteRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqDeleteRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqDeleteRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqDeleteRole& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqDeleteRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqDeleteRole";
  }
  protected:
  explicit ReqDeleteRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kNameFieldNumber = 2,
    kGameIdFieldNumber = 3,
  };
  // bytes account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 game_id = 3;
  void clear_game_id();
  int32_t game_id() const;
  void set_game_id(int32_t value);
  private:
  int32_t _internal_game_id() const;
  void _internal_set_game_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqDeleteRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t game_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ReqRecoverRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqRecoverRole) */ {
 public:
  inline ReqRecoverRole() : ReqRecoverRole(nullptr) {}
  ~ReqRecoverRole() override;
  explicit PROTOBUF_CONSTEXPR ReqRecoverRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRecoverRole(const ReqRecoverRole& from);
  ReqRecoverRole(ReqRecoverRole&& from) noexcept
    : ReqRecoverRole() {
    *this = ::std::move(from);
  }

  inline ReqRecoverRole& operator=(const ReqRecoverRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRecoverRole& operator=(ReqRecoverRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRecoverRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRecoverRole* internal_default_instance() {
    return reinterpret_cast<const ReqRecoverRole*>(
               &_ReqRecoverRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ReqRecoverRole& a, ReqRecoverRole& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRecoverRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRecoverRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRecoverRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRecoverRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRecoverRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqRecoverRole& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRecoverRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ReqRecoverRole";
  }
  protected:
  explicit ReqRecoverRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kNameFieldNumber = 2,
    kGameIdFieldNumber = 3,
  };
  // bytes account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 game_id = 3;
  void clear_game_id();
  int32_t game_id() const;
  void set_game_id(int32_t value);
  private:
  int32_t _internal_game_id() const;
  void _internal_set_game_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ReqRecoverRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t game_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class ServerHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.ServerHeartBeat) */ {
 public:
  inline ServerHeartBeat() : ServerHeartBeat(nullptr) {}
  ~ServerHeartBeat() override;
  explicit PROTOBUF_CONSTEXPR ServerHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerHeartBeat(const ServerHeartBeat& from);
  ServerHeartBeat(ServerHeartBeat&& from) noexcept
    : ServerHeartBeat() {
    *this = ::std::move(from);
  }

  inline ServerHeartBeat& operator=(const ServerHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerHeartBeat& operator=(ServerHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerHeartBeat* internal_default_instance() {
    return reinterpret_cast<const ServerHeartBeat*>(
               &_ServerHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ServerHeartBeat& a, ServerHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerHeartBeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerHeartBeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.ServerHeartBeat";
  }
  protected:
  explicit ServerHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // int32 count = 1;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.ServerHeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class RoleOnlineNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.RoleOnlineNotify) */ {
 public:
  inline RoleOnlineNotify() : RoleOnlineNotify(nullptr) {}
  ~RoleOnlineNotify() override;
  explicit PROTOBUF_CONSTEXPR RoleOnlineNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleOnlineNotify(const RoleOnlineNotify& from);
  RoleOnlineNotify(RoleOnlineNotify&& from) noexcept
    : RoleOnlineNotify() {
    *this = ::std::move(from);
  }

  inline RoleOnlineNotify& operator=(const RoleOnlineNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleOnlineNotify& operator=(RoleOnlineNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleOnlineNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleOnlineNotify* internal_default_instance() {
    return reinterpret_cast<const RoleOnlineNotify*>(
               &_RoleOnlineNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RoleOnlineNotify& a, RoleOnlineNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleOnlineNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleOnlineNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleOnlineNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleOnlineNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleOnlineNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleOnlineNotify& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleOnlineNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.RoleOnlineNotify";
  }
  protected:
  explicit RoleOnlineNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyIntListFieldNumber = 20,
    kPropertyFloatListFieldNumber = 21,
    kPropertyStringListFieldNumber = 22,
    kPropertyObjectListFieldNumber = 23,
    kPropertyVector2ListFieldNumber = 24,
    kPropertyVector3ListFieldNumber = 25,
    kNameFieldNumber = 5,
    kSelfFieldNumber = 1,
    kGameFieldNumber = 3,
    kProxyFieldNumber = 4,
    kBpFieldNumber = 6,
  };
  // repeated .NFMsg.PropertyInt property_int_list = 20;
  int property_int_list_size() const;
  private:
  int _internal_property_int_list_size() const;
  public:
  void clear_property_int_list();
  ::NFMsg::PropertyInt* mutable_property_int_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyInt >*
      mutable_property_int_list();
  private:
  const ::NFMsg::PropertyInt& _internal_property_int_list(int index) const;
  ::NFMsg::PropertyInt* _internal_add_property_int_list();
  public:
  const ::NFMsg::PropertyInt& property_int_list(int index) const;
  ::NFMsg::PropertyInt* add_property_int_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyInt >&
      property_int_list() const;

  // repeated .NFMsg.PropertyFloat property_float_list = 21;
  int property_float_list_size() const;
  private:
  int _internal_property_float_list_size() const;
  public:
  void clear_property_float_list();
  ::NFMsg::PropertyFloat* mutable_property_float_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyFloat >*
      mutable_property_float_list();
  private:
  const ::NFMsg::PropertyFloat& _internal_property_float_list(int index) const;
  ::NFMsg::PropertyFloat* _internal_add_property_float_list();
  public:
  const ::NFMsg::PropertyFloat& property_float_list(int index) const;
  ::NFMsg::PropertyFloat* add_property_float_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyFloat >&
      property_float_list() const;

  // repeated .NFMsg.PropertyString property_string_list = 22;
  int property_string_list_size() const;
  private:
  int _internal_property_string_list_size() const;
  public:
  void clear_property_string_list();
  ::NFMsg::PropertyString* mutable_property_string_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyString >*
      mutable_property_string_list();
  private:
  const ::NFMsg::PropertyString& _internal_property_string_list(int index) const;
  ::NFMsg::PropertyString* _internal_add_property_string_list();
  public:
  const ::NFMsg::PropertyString& property_string_list(int index) const;
  ::NFMsg::PropertyString* add_property_string_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyString >&
      property_string_list() const;

  // repeated .NFMsg.PropertyObject property_object_list = 23;
  int property_object_list_size() const;
  private:
  int _internal_property_object_list_size() const;
  public:
  void clear_property_object_list();
  ::NFMsg::PropertyObject* mutable_property_object_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyObject >*
      mutable_property_object_list();
  private:
  const ::NFMsg::PropertyObject& _internal_property_object_list(int index) const;
  ::NFMsg::PropertyObject* _internal_add_property_object_list();
  public:
  const ::NFMsg::PropertyObject& property_object_list(int index) const;
  ::NFMsg::PropertyObject* add_property_object_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyObject >&
      property_object_list() const;

  // repeated .NFMsg.PropertyVector2 property_vector2_list = 24;
  int property_vector2_list_size() const;
  private:
  int _internal_property_vector2_list_size() const;
  public:
  void clear_property_vector2_list();
  ::NFMsg::PropertyVector2* mutable_property_vector2_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector2 >*
      mutable_property_vector2_list();
  private:
  const ::NFMsg::PropertyVector2& _internal_property_vector2_list(int index) const;
  ::NFMsg::PropertyVector2* _internal_add_property_vector2_list();
  public:
  const ::NFMsg::PropertyVector2& property_vector2_list(int index) const;
  ::NFMsg::PropertyVector2* add_property_vector2_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector2 >&
      property_vector2_list() const;

  // repeated .NFMsg.PropertyVector3 property_vector3_list = 25;
  int property_vector3_list_size() const;
  private:
  int _internal_property_vector3_list_size() const;
  public:
  void clear_property_vector3_list();
  ::NFMsg::PropertyVector3* mutable_property_vector3_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector3 >*
      mutable_property_vector3_list();
  private:
  const ::NFMsg::PropertyVector3& _internal_property_vector3_list(int index) const;
  ::NFMsg::PropertyVector3* _internal_add_property_vector3_list();
  public:
  const ::NFMsg::PropertyVector3& property_vector3_list(int index) const;
  ::NFMsg::PropertyVector3* add_property_vector3_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector3 >&
      property_vector3_list() const;

  // bytes name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .NFMsg.Ident self = 1;
  bool has_self() const;
  private:
  bool _internal_has_self() const;
  public:
  void clear_self();
  const ::NFMsg::Ident& self() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_self();
  ::NFMsg::Ident* mutable_self();
  void set_allocated_self(::NFMsg::Ident* self);
  private:
  const ::NFMsg::Ident& _internal_self() const;
  ::NFMsg::Ident* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::NFMsg::Ident* self);
  ::NFMsg::Ident* unsafe_arena_release_self();

  // int32 game = 3;
  void clear_game();
  int32_t game() const;
  void set_game(int32_t value);
  private:
  int32_t _internal_game() const;
  void _internal_set_game(int32_t value);
  public:

  // int32 proxy = 4;
  void clear_proxy();
  int32_t proxy() const;
  void set_proxy(int32_t value);
  private:
  int32_t _internal_proxy() const;
  void _internal_set_proxy(int32_t value);
  public:

  // int32 bp = 6;
  void clear_bp();
  int32_t bp() const;
  void set_bp(int32_t value);
  private:
  int32_t _internal_bp() const;
  void _internal_set_bp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.RoleOnlineNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyInt > property_int_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyFloat > property_float_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyString > property_string_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyObject > property_object_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector2 > property_vector2_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector3 > property_vector3_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::NFMsg::Ident* self_;
  int32_t game_;
  int32_t proxy_;
  int32_t bp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class RoleOfflineNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.RoleOfflineNotify) */ {
 public:
  inline RoleOfflineNotify() : RoleOfflineNotify(nullptr) {}
  ~RoleOfflineNotify() override;
  explicit PROTOBUF_CONSTEXPR RoleOfflineNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleOfflineNotify(const RoleOfflineNotify& from);
  RoleOfflineNotify(RoleOfflineNotify&& from) noexcept
    : RoleOfflineNotify() {
    *this = ::std::move(from);
  }

  inline RoleOfflineNotify& operator=(const RoleOfflineNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleOfflineNotify& operator=(RoleOfflineNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleOfflineNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleOfflineNotify* internal_default_instance() {
    return reinterpret_cast<const RoleOfflineNotify*>(
               &_RoleOfflineNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RoleOfflineNotify& a, RoleOfflineNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleOfflineNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleOfflineNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleOfflineNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleOfflineNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleOfflineNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleOfflineNotify& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleOfflineNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.RoleOfflineNotify";
  }
  protected:
  explicit RoleOfflineNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelfFieldNumber = 1,
    kClanFieldNumber = 2,
    kGameFieldNumber = 3,
    kProxyFieldNumber = 4,
  };
  // .NFMsg.Ident self = 1;
  bool has_self() const;
  private:
  bool _internal_has_self() const;
  public:
  void clear_self();
  const ::NFMsg::Ident& self() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_self();
  ::NFMsg::Ident* mutable_self();
  void set_allocated_self(::NFMsg::Ident* self);
  private:
  const ::NFMsg::Ident& _internal_self() const;
  ::NFMsg::Ident* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::NFMsg::Ident* self);
  ::NFMsg::Ident* unsafe_arena_release_self();

  // .NFMsg.Ident clan = 2;
  bool has_clan() const;
  private:
  bool _internal_has_clan() const;
  public:
  void clear_clan();
  const ::NFMsg::Ident& clan() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_clan();
  ::NFMsg::Ident* mutable_clan();
  void set_allocated_clan(::NFMsg::Ident* clan);
  private:
  const ::NFMsg::Ident& _internal_clan() const;
  ::NFMsg::Ident* _internal_mutable_clan();
  public:
  void unsafe_arena_set_allocated_clan(
      ::NFMsg::Ident* clan);
  ::NFMsg::Ident* unsafe_arena_release_clan();

  // int32 game = 3;
  void clear_game();
  int32_t game() const;
  void set_game(int32_t value);
  private:
  int32_t _internal_game() const;
  void _internal_set_game(int32_t value);
  public:

  // int32 proxy = 4;
  void clear_proxy();
  int32_t proxy() const;
  void set_proxy(int32_t value);
  private:
  int32_t _internal_proxy() const;
  void _internal_set_proxy(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NFMsg.RoleOfflineNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::NFMsg::Ident* self_;
  ::NFMsg::Ident* clan_;
  int32_t game_;
  int32_t proxy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// -------------------------------------------------------------------

class RoleDataPack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NFMsg.RoleDataPack) */ {
 public:
  inline RoleDataPack() : RoleDataPack(nullptr) {}
  ~RoleDataPack() override;
  explicit PROTOBUF_CONSTEXPR RoleDataPack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleDataPack(const RoleDataPack& from);
  RoleDataPack(RoleDataPack&& from) noexcept
    : RoleDataPack() {
    *this = ::std::move(from);
  }

  inline RoleDataPack& operator=(const RoleDataPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleDataPack& operator=(RoleDataPack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleDataPack& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleDataPack* internal_default_instance() {
    return reinterpret_cast<const RoleDataPack*>(
               &_RoleDataPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RoleDataPack& a, RoleDataPack& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleDataPack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleDataPack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleDataPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleDataPack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleDataPack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleDataPack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleDataPack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NFMsg.RoleDataPack";
  }
  protected:
  explicit RoleDataPack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPropertyFieldNumber = 2,
    kRecordFieldNumber = 3,
  };
  // .NFMsg.Ident id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::NFMsg::Ident& id() const;
  PROTOBUF_NODISCARD ::NFMsg::Ident* release_id();
  ::NFMsg::Ident* mutable_id();
  void set_allocated_id(::NFMsg::Ident* id);
  private:
  const ::NFMsg::Ident& _internal_id() const;
  ::NFMsg::Ident* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::NFMsg::Ident* id);
  ::NFMsg::Ident* unsafe_arena_release_id();

  // .NFMsg.ObjectPropertyList property = 2;
  bool has_property() const;
  private:
  bool _internal_has_property() const;
  public:
  void clear_property();
  const ::NFMsg::ObjectPropertyList& property() const;
  PROTOBUF_NODISCARD ::NFMsg::ObjectPropertyList* release_property();
  ::NFMsg::ObjectPropertyList* mutable_property();
  void set_allocated_property(::NFMsg::ObjectPropertyList* property);
  private:
  const ::NFMsg::ObjectPropertyList& _internal_property() const;
  ::NFMsg::ObjectPropertyList* _internal_mutable_property();
  public:
  void unsafe_arena_set_allocated_property(
      ::NFMsg::ObjectPropertyList* property);
  ::NFMsg::ObjectPropertyList* unsafe_arena_release_property();

  // .NFMsg.ObjectRecordList record = 3;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::NFMsg::ObjectRecordList& record() const;
  PROTOBUF_NODISCARD ::NFMsg::ObjectRecordList* release_record();
  ::NFMsg::ObjectRecordList* mutable_record();
  void set_allocated_record(::NFMsg::ObjectRecordList* record);
  private:
  const ::NFMsg::ObjectRecordList& _internal_record() const;
  ::NFMsg::ObjectRecordList* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::NFMsg::ObjectRecordList* record);
  ::NFMsg::ObjectRecordList* unsafe_arena_release_record();

  // @@protoc_insertion_point(class_scope:NFMsg.RoleDataPack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::NFMsg::Ident* id_;
  ::NFMsg::ObjectPropertyList* property_;
  ::NFMsg::ObjectRecordList* record_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NFMsgPreGame_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerInfoReport

// int32 server_id = 1;
inline void ServerInfoReport::clear_server_id() {
  server_id_ = 0;
}
inline int32_t ServerInfoReport::_internal_server_id() const {
  return server_id_;
}
inline int32_t ServerInfoReport::server_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReport.server_id)
  return _internal_server_id();
}
inline void ServerInfoReport::_internal_set_server_id(int32_t value) {
  
  server_id_ = value;
}
inline void ServerInfoReport::set_server_id(int32_t value) {
  _internal_set_server_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfoReport.server_id)
}

// bytes server_name = 2;
inline void ServerInfoReport::clear_server_name() {
  server_name_.ClearToEmpty();
}
inline const std::string& ServerInfoReport::server_name() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReport.server_name)
  return _internal_server_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfoReport::set_server_name(ArgT0&& arg0, ArgT... args) {
 
 server_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfoReport.server_name)
}
inline std::string* ServerInfoReport::mutable_server_name() {
  std::string* _s = _internal_mutable_server_name();
  // @@protoc_insertion_point(field_mutable:NFMsg.ServerInfoReport.server_name)
  return _s;
}
inline const std::string& ServerInfoReport::_internal_server_name() const {
  return server_name_.Get();
}
inline void ServerInfoReport::_internal_set_server_name(const std::string& value) {
  
  server_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfoReport::_internal_mutable_server_name() {
  
  return server_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfoReport::release_server_name() {
  // @@protoc_insertion_point(field_release:NFMsg.ServerInfoReport.server_name)
  return server_name_.Release();
}
inline void ServerInfoReport::set_allocated_server_name(std::string* server_name) {
  if (server_name != nullptr) {
    
  } else {
    
  }
  server_name_.SetAllocated(server_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_name_.IsDefault()) {
    server_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ServerInfoReport.server_name)
}

// bytes server_ip = 3;
inline void ServerInfoReport::clear_server_ip() {
  server_ip_.ClearToEmpty();
}
inline const std::string& ServerInfoReport::server_ip() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReport.server_ip)
  return _internal_server_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfoReport::set_server_ip(ArgT0&& arg0, ArgT... args) {
 
 server_ip_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfoReport.server_ip)
}
inline std::string* ServerInfoReport::mutable_server_ip() {
  std::string* _s = _internal_mutable_server_ip();
  // @@protoc_insertion_point(field_mutable:NFMsg.ServerInfoReport.server_ip)
  return _s;
}
inline const std::string& ServerInfoReport::_internal_server_ip() const {
  return server_ip_.Get();
}
inline void ServerInfoReport::_internal_set_server_ip(const std::string& value) {
  
  server_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfoReport::_internal_mutable_server_ip() {
  
  return server_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfoReport::release_server_ip() {
  // @@protoc_insertion_point(field_release:NFMsg.ServerInfoReport.server_ip)
  return server_ip_.Release();
}
inline void ServerInfoReport::set_allocated_server_ip(std::string* server_ip) {
  if (server_ip != nullptr) {
    
  } else {
    
  }
  server_ip_.SetAllocated(server_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_ip_.IsDefault()) {
    server_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ServerInfoReport.server_ip)
}

// int32 server_port = 4;
inline void ServerInfoReport::clear_server_port() {
  server_port_ = 0;
}
inline int32_t ServerInfoReport::_internal_server_port() const {
  return server_port_;
}
inline int32_t ServerInfoReport::server_port() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReport.server_port)
  return _internal_server_port();
}
inline void ServerInfoReport::_internal_set_server_port(int32_t value) {
  
  server_port_ = value;
}
inline void ServerInfoReport::set_server_port(int32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfoReport.server_port)
}

// int32 server_max_online = 5;
inline void ServerInfoReport::clear_server_max_online() {
  server_max_online_ = 0;
}
inline int32_t ServerInfoReport::_internal_server_max_online() const {
  return server_max_online_;
}
inline int32_t ServerInfoReport::server_max_online() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReport.server_max_online)
  return _internal_server_max_online();
}
inline void ServerInfoReport::_internal_set_server_max_online(int32_t value) {
  
  server_max_online_ = value;
}
inline void ServerInfoReport::set_server_max_online(int32_t value) {
  _internal_set_server_max_online(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfoReport.server_max_online)
}

// int32 server_cur_count = 6;
inline void ServerInfoReport::clear_server_cur_count() {
  server_cur_count_ = 0;
}
inline int32_t ServerInfoReport::_internal_server_cur_count() const {
  return server_cur_count_;
}
inline int32_t ServerInfoReport::server_cur_count() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReport.server_cur_count)
  return _internal_server_cur_count();
}
inline void ServerInfoReport::_internal_set_server_cur_count(int32_t value) {
  
  server_cur_count_ = value;
}
inline void ServerInfoReport::set_server_cur_count(int32_t value) {
  _internal_set_server_cur_count(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfoReport.server_cur_count)
}

// .NFMsg.EServerState server_state = 7;
inline void ServerInfoReport::clear_server_state() {
  server_state_ = 0;
}
inline ::NFMsg::EServerState ServerInfoReport::_internal_server_state() const {
  return static_cast< ::NFMsg::EServerState >(server_state_);
}
inline ::NFMsg::EServerState ServerInfoReport::server_state() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReport.server_state)
  return _internal_server_state();
}
inline void ServerInfoReport::_internal_set_server_state(::NFMsg::EServerState value) {
  
  server_state_ = value;
}
inline void ServerInfoReport::set_server_state(::NFMsg::EServerState value) {
  _internal_set_server_state(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfoReport.server_state)
}

// int32 server_type = 8;
inline void ServerInfoReport::clear_server_type() {
  server_type_ = 0;
}
inline int32_t ServerInfoReport::_internal_server_type() const {
  return server_type_;
}
inline int32_t ServerInfoReport::server_type() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReport.server_type)
  return _internal_server_type();
}
inline void ServerInfoReport::_internal_set_server_type(int32_t value) {
  
  server_type_ = value;
}
inline void ServerInfoReport::set_server_type(int32_t value) {
  _internal_set_server_type(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfoReport.server_type)
}

// -------------------------------------------------------------------

// ServerInfoReportList

// repeated .NFMsg.ServerInfoReport server_list = 1;
inline int ServerInfoReportList::_internal_server_list_size() const {
  return server_list_.size();
}
inline int ServerInfoReportList::server_list_size() const {
  return _internal_server_list_size();
}
inline void ServerInfoReportList::clear_server_list() {
  server_list_.Clear();
}
inline ::NFMsg::ServerInfoReport* ServerInfoReportList::mutable_server_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.ServerInfoReportList.server_list)
  return server_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfoReport >*
ServerInfoReportList::mutable_server_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.ServerInfoReportList.server_list)
  return &server_list_;
}
inline const ::NFMsg::ServerInfoReport& ServerInfoReportList::_internal_server_list(int index) const {
  return server_list_.Get(index);
}
inline const ::NFMsg::ServerInfoReport& ServerInfoReportList::server_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfoReportList.server_list)
  return _internal_server_list(index);
}
inline ::NFMsg::ServerInfoReport* ServerInfoReportList::_internal_add_server_list() {
  return server_list_.Add();
}
inline ::NFMsg::ServerInfoReport* ServerInfoReportList::add_server_list() {
  ::NFMsg::ServerInfoReport* _add = _internal_add_server_list();
  // @@protoc_insertion_point(field_add:NFMsg.ServerInfoReportList.server_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfoReport >&
ServerInfoReportList::server_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.ServerInfoReportList.server_list)
  return server_list_;
}

// -------------------------------------------------------------------

// AckEventResult

// .NFMsg.EGameEventCode event_code = 1;
inline void AckEventResult::clear_event_code() {
  event_code_ = 0;
}
inline ::NFMsg::EGameEventCode AckEventResult::_internal_event_code() const {
  return static_cast< ::NFMsg::EGameEventCode >(event_code_);
}
inline ::NFMsg::EGameEventCode AckEventResult::event_code() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckEventResult.event_code)
  return _internal_event_code();
}
inline void AckEventResult::_internal_set_event_code(::NFMsg::EGameEventCode value) {
  
  event_code_ = value;
}
inline void AckEventResult::set_event_code(::NFMsg::EGameEventCode value) {
  _internal_set_event_code(value);
  // @@protoc_insertion_point(field_set:NFMsg.AckEventResult.event_code)
}

// .NFMsg.Ident event_object = 2;
inline bool AckEventResult::_internal_has_event_object() const {
  return this != internal_default_instance() && event_object_ != nullptr;
}
inline bool AckEventResult::has_event_object() const {
  return _internal_has_event_object();
}
inline const ::NFMsg::Ident& AckEventResult::_internal_event_object() const {
  const ::NFMsg::Ident* p = event_object_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& AckEventResult::event_object() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckEventResult.event_object)
  return _internal_event_object();
}
inline void AckEventResult::unsafe_arena_set_allocated_event_object(
    ::NFMsg::Ident* event_object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_object_);
  }
  event_object_ = event_object;
  if (event_object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.AckEventResult.event_object)
}
inline ::NFMsg::Ident* AckEventResult::release_event_object() {
  
  ::NFMsg::Ident* temp = event_object_;
  event_object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* AckEventResult::unsafe_arena_release_event_object() {
  // @@protoc_insertion_point(field_release:NFMsg.AckEventResult.event_object)
  
  ::NFMsg::Ident* temp = event_object_;
  event_object_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* AckEventResult::_internal_mutable_event_object() {
  
  if (event_object_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    event_object_ = p;
  }
  return event_object_;
}
inline ::NFMsg::Ident* AckEventResult::mutable_event_object() {
  ::NFMsg::Ident* _msg = _internal_mutable_event_object();
  // @@protoc_insertion_point(field_mutable:NFMsg.AckEventResult.event_object)
  return _msg;
}
inline void AckEventResult::set_allocated_event_object(::NFMsg::Ident* event_object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_object_);
  }
  if (event_object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_object));
    if (message_arena != submessage_arena) {
      event_object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_object, submessage_arena);
    }
    
  } else {
    
  }
  event_object_ = event_object;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckEventResult.event_object)
}

// .NFMsg.Ident event_client = 3;
inline bool AckEventResult::_internal_has_event_client() const {
  return this != internal_default_instance() && event_client_ != nullptr;
}
inline bool AckEventResult::has_event_client() const {
  return _internal_has_event_client();
}
inline const ::NFMsg::Ident& AckEventResult::_internal_event_client() const {
  const ::NFMsg::Ident* p = event_client_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& AckEventResult::event_client() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckEventResult.event_client)
  return _internal_event_client();
}
inline void AckEventResult::unsafe_arena_set_allocated_event_client(
    ::NFMsg::Ident* event_client) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_client_);
  }
  event_client_ = event_client;
  if (event_client) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.AckEventResult.event_client)
}
inline ::NFMsg::Ident* AckEventResult::release_event_client() {
  
  ::NFMsg::Ident* temp = event_client_;
  event_client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* AckEventResult::unsafe_arena_release_event_client() {
  // @@protoc_insertion_point(field_release:NFMsg.AckEventResult.event_client)
  
  ::NFMsg::Ident* temp = event_client_;
  event_client_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* AckEventResult::_internal_mutable_event_client() {
  
  if (event_client_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    event_client_ = p;
  }
  return event_client_;
}
inline ::NFMsg::Ident* AckEventResult::mutable_event_client() {
  ::NFMsg::Ident* _msg = _internal_mutable_event_client();
  // @@protoc_insertion_point(field_mutable:NFMsg.AckEventResult.event_client)
  return _msg;
}
inline void AckEventResult::set_allocated_event_client(::NFMsg::Ident* event_client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_client_);
  }
  if (event_client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_client));
    if (message_arena != submessage_arena) {
      event_client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_client, submessage_arena);
    }
    
  } else {
    
  }
  event_client_ = event_client;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckEventResult.event_client)
}

// -------------------------------------------------------------------

// ReqAccountLogin

// bytes account = 2;
inline void ReqAccountLogin::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqAccountLogin::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAccountLogin::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.account)
}
inline std::string* ReqAccountLogin::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAccountLogin.account)
  return _s;
}
inline const std::string& ReqAccountLogin::_internal_account() const {
  return account_.Get();
}
inline void ReqAccountLogin::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAccountLogin.account)
  return account_.Release();
}
inline void ReqAccountLogin::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAccountLogin.account)
}

// bytes password = 3;
inline void ReqAccountLogin::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& ReqAccountLogin::password() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAccountLogin::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.password)
}
inline std::string* ReqAccountLogin::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAccountLogin.password)
  return _s;
}
inline const std::string& ReqAccountLogin::_internal_password() const {
  return password_.Get();
}
inline void ReqAccountLogin::_internal_set_password(const std::string& value) {
  
  password_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::_internal_mutable_password() {
  
  return password_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::release_password() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAccountLogin.password)
  return password_.Release();
}
inline void ReqAccountLogin::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault()) {
    password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAccountLogin.password)
}

// bytes security_code = 4;
inline void ReqAccountLogin::clear_security_code() {
  security_code_.ClearToEmpty();
}
inline const std::string& ReqAccountLogin::security_code() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.security_code)
  return _internal_security_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAccountLogin::set_security_code(ArgT0&& arg0, ArgT... args) {
 
 security_code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.security_code)
}
inline std::string* ReqAccountLogin::mutable_security_code() {
  std::string* _s = _internal_mutable_security_code();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAccountLogin.security_code)
  return _s;
}
inline const std::string& ReqAccountLogin::_internal_security_code() const {
  return security_code_.Get();
}
inline void ReqAccountLogin::_internal_set_security_code(const std::string& value) {
  
  security_code_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::_internal_mutable_security_code() {
  
  return security_code_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::release_security_code() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAccountLogin.security_code)
  return security_code_.Release();
}
inline void ReqAccountLogin::set_allocated_security_code(std::string* security_code) {
  if (security_code != nullptr) {
    
  } else {
    
  }
  security_code_.SetAllocated(security_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (security_code_.IsDefault()) {
    security_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAccountLogin.security_code)
}

// bytes signBuff = 5;
inline void ReqAccountLogin::clear_signbuff() {
  signbuff_.ClearToEmpty();
}
inline const std::string& ReqAccountLogin::signbuff() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.signBuff)
  return _internal_signbuff();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAccountLogin::set_signbuff(ArgT0&& arg0, ArgT... args) {
 
 signbuff_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.signBuff)
}
inline std::string* ReqAccountLogin::mutable_signbuff() {
  std::string* _s = _internal_mutable_signbuff();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAccountLogin.signBuff)
  return _s;
}
inline const std::string& ReqAccountLogin::_internal_signbuff() const {
  return signbuff_.Get();
}
inline void ReqAccountLogin::_internal_set_signbuff(const std::string& value) {
  
  signbuff_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::_internal_mutable_signbuff() {
  
  return signbuff_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::release_signbuff() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAccountLogin.signBuff)
  return signbuff_.Release();
}
inline void ReqAccountLogin::set_allocated_signbuff(std::string* signbuff) {
  if (signbuff != nullptr) {
    
  } else {
    
  }
  signbuff_.SetAllocated(signbuff, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signbuff_.IsDefault()) {
    signbuff_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAccountLogin.signBuff)
}

// int32 clientVersion = 6;
inline void ReqAccountLogin::clear_clientversion() {
  clientversion_ = 0;
}
inline int32_t ReqAccountLogin::_internal_clientversion() const {
  return clientversion_;
}
inline int32_t ReqAccountLogin::clientversion() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.clientVersion)
  return _internal_clientversion();
}
inline void ReqAccountLogin::_internal_set_clientversion(int32_t value) {
  
  clientversion_ = value;
}
inline void ReqAccountLogin::set_clientversion(int32_t value) {
  _internal_set_clientversion(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.clientVersion)
}

// .NFMsg.ELoginMode loginMode = 7;
inline void ReqAccountLogin::clear_loginmode() {
  loginmode_ = 0;
}
inline ::NFMsg::ELoginMode ReqAccountLogin::_internal_loginmode() const {
  return static_cast< ::NFMsg::ELoginMode >(loginmode_);
}
inline ::NFMsg::ELoginMode ReqAccountLogin::loginmode() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.loginMode)
  return _internal_loginmode();
}
inline void ReqAccountLogin::_internal_set_loginmode(::NFMsg::ELoginMode value) {
  
  loginmode_ = value;
}
inline void ReqAccountLogin::set_loginmode(::NFMsg::ELoginMode value) {
  _internal_set_loginmode(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.loginMode)
}

// int32 clientIP = 8;
inline void ReqAccountLogin::clear_clientip() {
  clientip_ = 0;
}
inline int32_t ReqAccountLogin::_internal_clientip() const {
  return clientip_;
}
inline int32_t ReqAccountLogin::clientip() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.clientIP)
  return _internal_clientip();
}
inline void ReqAccountLogin::_internal_set_clientip(int32_t value) {
  
  clientip_ = value;
}
inline void ReqAccountLogin::set_clientip(int32_t value) {
  _internal_set_clientip(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.clientIP)
}

// int64 clientMAC = 9;
inline void ReqAccountLogin::clear_clientmac() {
  clientmac_ = int64_t{0};
}
inline int64_t ReqAccountLogin::_internal_clientmac() const {
  return clientmac_;
}
inline int64_t ReqAccountLogin::clientmac() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.clientMAC)
  return _internal_clientmac();
}
inline void ReqAccountLogin::_internal_set_clientmac(int64_t value) {
  
  clientmac_ = value;
}
inline void ReqAccountLogin::set_clientmac(int64_t value) {
  _internal_set_clientmac(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.clientMAC)
}

// bytes device_info = 10;
inline void ReqAccountLogin::clear_device_info() {
  device_info_.ClearToEmpty();
}
inline const std::string& ReqAccountLogin::device_info() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.device_info)
  return _internal_device_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAccountLogin::set_device_info(ArgT0&& arg0, ArgT... args) {
 
 device_info_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.device_info)
}
inline std::string* ReqAccountLogin::mutable_device_info() {
  std::string* _s = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAccountLogin.device_info)
  return _s;
}
inline const std::string& ReqAccountLogin::_internal_device_info() const {
  return device_info_.Get();
}
inline void ReqAccountLogin::_internal_set_device_info(const std::string& value) {
  
  device_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::_internal_mutable_device_info() {
  
  return device_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::release_device_info() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAccountLogin.device_info)
  return device_info_.Release();
}
inline void ReqAccountLogin::set_allocated_device_info(std::string* device_info) {
  if (device_info != nullptr) {
    
  } else {
    
  }
  device_info_.SetAllocated(device_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_info_.IsDefault()) {
    device_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAccountLogin.device_info)
}

// bytes extra_info = 11;
inline void ReqAccountLogin::clear_extra_info() {
  extra_info_.ClearToEmpty();
}
inline const std::string& ReqAccountLogin::extra_info() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.extra_info)
  return _internal_extra_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAccountLogin::set_extra_info(ArgT0&& arg0, ArgT... args) {
 
 extra_info_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.extra_info)
}
inline std::string* ReqAccountLogin::mutable_extra_info() {
  std::string* _s = _internal_mutable_extra_info();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAccountLogin.extra_info)
  return _s;
}
inline const std::string& ReqAccountLogin::_internal_extra_info() const {
  return extra_info_.Get();
}
inline void ReqAccountLogin::_internal_set_extra_info(const std::string& value) {
  
  extra_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::_internal_mutable_extra_info() {
  
  return extra_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAccountLogin::release_extra_info() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAccountLogin.extra_info)
  return extra_info_.Release();
}
inline void ReqAccountLogin::set_allocated_extra_info(std::string* extra_info) {
  if (extra_info != nullptr) {
    
  } else {
    
  }
  extra_info_.SetAllocated(extra_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_info_.IsDefault()) {
    extra_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAccountLogin.extra_info)
}

// int32 platform_type = 12;
inline void ReqAccountLogin::clear_platform_type() {
  platform_type_ = 0;
}
inline int32_t ReqAccountLogin::_internal_platform_type() const {
  return platform_type_;
}
inline int32_t ReqAccountLogin::platform_type() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogin.platform_type)
  return _internal_platform_type();
}
inline void ReqAccountLogin::_internal_set_platform_type(int32_t value) {
  
  platform_type_ = value;
}
inline void ReqAccountLogin::set_platform_type(int32_t value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogin.platform_type)
}

// -------------------------------------------------------------------

// ReqAccountLogout

// bytes account = 2;
inline void ReqAccountLogout::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqAccountLogout::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogout.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAccountLogout::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogout.account)
}
inline std::string* ReqAccountLogout::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAccountLogout.account)
  return _s;
}
inline const std::string& ReqAccountLogout::_internal_account() const {
  return account_.Get();
}
inline void ReqAccountLogout::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAccountLogout::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAccountLogout::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAccountLogout.account)
  return account_.Release();
}
inline void ReqAccountLogout::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAccountLogout.account)
}

// bytes extra_info = 3;
inline void ReqAccountLogout::clear_extra_info() {
  extra_info_.ClearToEmpty();
}
inline const std::string& ReqAccountLogout::extra_info() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAccountLogout.extra_info)
  return _internal_extra_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAccountLogout::set_extra_info(ArgT0&& arg0, ArgT... args) {
 
 extra_info_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqAccountLogout.extra_info)
}
inline std::string* ReqAccountLogout::mutable_extra_info() {
  std::string* _s = _internal_mutable_extra_info();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAccountLogout.extra_info)
  return _s;
}
inline const std::string& ReqAccountLogout::_internal_extra_info() const {
  return extra_info_.Get();
}
inline void ReqAccountLogout::_internal_set_extra_info(const std::string& value) {
  
  extra_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAccountLogout::_internal_mutable_extra_info() {
  
  return extra_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAccountLogout::release_extra_info() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAccountLogout.extra_info)
  return extra_info_.Release();
}
inline void ReqAccountLogout::set_allocated_extra_info(std::string* extra_info) {
  if (extra_info != nullptr) {
    
  } else {
    
  }
  extra_info_.SetAllocated(extra_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_info_.IsDefault()) {
    extra_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAccountLogout.extra_info)
}

// -------------------------------------------------------------------

// ServerInfo

// int32 server_id = 1;
inline void ServerInfo::clear_server_id() {
  server_id_ = 0;
}
inline int32_t ServerInfo::_internal_server_id() const {
  return server_id_;
}
inline int32_t ServerInfo::server_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfo.server_id)
  return _internal_server_id();
}
inline void ServerInfo::_internal_set_server_id(int32_t value) {
  
  server_id_ = value;
}
inline void ServerInfo::set_server_id(int32_t value) {
  _internal_set_server_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfo.server_id)
}

// bytes name = 2;
inline void ServerInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServerInfo::name() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfo.name)
}
inline std::string* ServerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NFMsg.ServerInfo.name)
  return _s;
}
inline const std::string& ServerInfo::_internal_name() const {
  return name_.Get();
}
inline void ServerInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_name() {
  // @@protoc_insertion_point(field_release:NFMsg.ServerInfo.name)
  return name_.Release();
}
inline void ServerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ServerInfo.name)
}

// int32 wait_count = 3;
inline void ServerInfo::clear_wait_count() {
  wait_count_ = 0;
}
inline int32_t ServerInfo::_internal_wait_count() const {
  return wait_count_;
}
inline int32_t ServerInfo::wait_count() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfo.wait_count)
  return _internal_wait_count();
}
inline void ServerInfo::_internal_set_wait_count(int32_t value) {
  
  wait_count_ = value;
}
inline void ServerInfo::set_wait_count(int32_t value) {
  _internal_set_wait_count(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfo.wait_count)
}

// .NFMsg.EServerState status = 4;
inline void ServerInfo::clear_status() {
  status_ = 0;
}
inline ::NFMsg::EServerState ServerInfo::_internal_status() const {
  return static_cast< ::NFMsg::EServerState >(status_);
}
inline ::NFMsg::EServerState ServerInfo::status() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerInfo.status)
  return _internal_status();
}
inline void ServerInfo::_internal_set_status(::NFMsg::EServerState value) {
  
  status_ = value;
}
inline void ServerInfo::set_status(::NFMsg::EServerState value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerInfo.status)
}

// -------------------------------------------------------------------

// ReqServerList

// .NFMsg.ReqServerListType type = 1;
inline void ReqServerList::clear_type() {
  type_ = 0;
}
inline ::NFMsg::ReqServerListType ReqServerList::_internal_type() const {
  return static_cast< ::NFMsg::ReqServerListType >(type_);
}
inline ::NFMsg::ReqServerListType ReqServerList::type() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqServerList.type)
  return _internal_type();
}
inline void ReqServerList::_internal_set_type(::NFMsg::ReqServerListType value) {
  
  type_ = value;
}
inline void ReqServerList::set_type(::NFMsg::ReqServerListType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqServerList.type)
}

// -------------------------------------------------------------------

// AckServerList

// .NFMsg.ReqServerListType type = 1;
inline void AckServerList::clear_type() {
  type_ = 0;
}
inline ::NFMsg::ReqServerListType AckServerList::_internal_type() const {
  return static_cast< ::NFMsg::ReqServerListType >(type_);
}
inline ::NFMsg::ReqServerListType AckServerList::type() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckServerList.type)
  return _internal_type();
}
inline void AckServerList::_internal_set_type(::NFMsg::ReqServerListType value) {
  
  type_ = value;
}
inline void AckServerList::set_type(::NFMsg::ReqServerListType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:NFMsg.AckServerList.type)
}

// repeated .NFMsg.ServerInfo info = 2;
inline int AckServerList::_internal_info_size() const {
  return info_.size();
}
inline int AckServerList::info_size() const {
  return _internal_info_size();
}
inline void AckServerList::clear_info() {
  info_.Clear();
}
inline ::NFMsg::ServerInfo* AckServerList::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.AckServerList.info)
  return info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfo >*
AckServerList::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.AckServerList.info)
  return &info_;
}
inline const ::NFMsg::ServerInfo& AckServerList::_internal_info(int index) const {
  return info_.Get(index);
}
inline const ::NFMsg::ServerInfo& AckServerList::info(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.AckServerList.info)
  return _internal_info(index);
}
inline ::NFMsg::ServerInfo* AckServerList::_internal_add_info() {
  return info_.Add();
}
inline ::NFMsg::ServerInfo* AckServerList::add_info() {
  ::NFMsg::ServerInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:NFMsg.AckServerList.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::ServerInfo >&
AckServerList::info() const {
  // @@protoc_insertion_point(field_list:NFMsg.AckServerList.info)
  return info_;
}

// -------------------------------------------------------------------

// ReqConnectWorld

// int32 world_id = 1;
inline void ReqConnectWorld::clear_world_id() {
  world_id_ = 0;
}
inline int32_t ReqConnectWorld::_internal_world_id() const {
  return world_id_;
}
inline int32_t ReqConnectWorld::world_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqConnectWorld.world_id)
  return _internal_world_id();
}
inline void ReqConnectWorld::_internal_set_world_id(int32_t value) {
  
  world_id_ = value;
}
inline void ReqConnectWorld::set_world_id(int32_t value) {
  _internal_set_world_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqConnectWorld.world_id)
}

// bytes account = 2;
inline void ReqConnectWorld::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqConnectWorld::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqConnectWorld.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqConnectWorld::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqConnectWorld.account)
}
inline std::string* ReqConnectWorld::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqConnectWorld.account)
  return _s;
}
inline const std::string& ReqConnectWorld::_internal_account() const {
  return account_.Get();
}
inline void ReqConnectWorld::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqConnectWorld::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqConnectWorld::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqConnectWorld.account)
  return account_.Release();
}
inline void ReqConnectWorld::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqConnectWorld.account)
}

// .NFMsg.Ident sender = 3;
inline bool ReqConnectWorld::_internal_has_sender() const {
  return this != internal_default_instance() && sender_ != nullptr;
}
inline bool ReqConnectWorld::has_sender() const {
  return _internal_has_sender();
}
inline const ::NFMsg::Ident& ReqConnectWorld::_internal_sender() const {
  const ::NFMsg::Ident* p = sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& ReqConnectWorld::sender() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqConnectWorld.sender)
  return _internal_sender();
}
inline void ReqConnectWorld::unsafe_arena_set_allocated_sender(
    ::NFMsg::Ident* sender) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_);
  }
  sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.ReqConnectWorld.sender)
}
inline ::NFMsg::Ident* ReqConnectWorld::release_sender() {
  
  ::NFMsg::Ident* temp = sender_;
  sender_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* ReqConnectWorld::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqConnectWorld.sender)
  
  ::NFMsg::Ident* temp = sender_;
  sender_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* ReqConnectWorld::_internal_mutable_sender() {
  
  if (sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    sender_ = p;
  }
  return sender_;
}
inline ::NFMsg::Ident* ReqConnectWorld::mutable_sender() {
  ::NFMsg::Ident* _msg = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqConnectWorld.sender)
  return _msg;
}
inline void ReqConnectWorld::set_allocated_sender(::NFMsg::Ident* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_);
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender));
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqConnectWorld.sender)
}

// int32 login_id = 4;
inline void ReqConnectWorld::clear_login_id() {
  login_id_ = 0;
}
inline int32_t ReqConnectWorld::_internal_login_id() const {
  return login_id_;
}
inline int32_t ReqConnectWorld::login_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqConnectWorld.login_id)
  return _internal_login_id();
}
inline void ReqConnectWorld::_internal_set_login_id(int32_t value) {
  
  login_id_ = value;
}
inline void ReqConnectWorld::set_login_id(int32_t value) {
  _internal_set_login_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqConnectWorld.login_id)
}

// -------------------------------------------------------------------

// AckConnectWorldResult

// int32 world_id = 1;
inline void AckConnectWorldResult::clear_world_id() {
  world_id_ = 0;
}
inline int32_t AckConnectWorldResult::_internal_world_id() const {
  return world_id_;
}
inline int32_t AckConnectWorldResult::world_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckConnectWorldResult.world_id)
  return _internal_world_id();
}
inline void AckConnectWorldResult::_internal_set_world_id(int32_t value) {
  
  world_id_ = value;
}
inline void AckConnectWorldResult::set_world_id(int32_t value) {
  _internal_set_world_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.AckConnectWorldResult.world_id)
}

// .NFMsg.Ident sender = 2;
inline bool AckConnectWorldResult::_internal_has_sender() const {
  return this != internal_default_instance() && sender_ != nullptr;
}
inline bool AckConnectWorldResult::has_sender() const {
  return _internal_has_sender();
}
inline const ::NFMsg::Ident& AckConnectWorldResult::_internal_sender() const {
  const ::NFMsg::Ident* p = sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& AckConnectWorldResult::sender() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckConnectWorldResult.sender)
  return _internal_sender();
}
inline void AckConnectWorldResult::unsafe_arena_set_allocated_sender(
    ::NFMsg::Ident* sender) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_);
  }
  sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.AckConnectWorldResult.sender)
}
inline ::NFMsg::Ident* AckConnectWorldResult::release_sender() {
  
  ::NFMsg::Ident* temp = sender_;
  sender_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* AckConnectWorldResult::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:NFMsg.AckConnectWorldResult.sender)
  
  ::NFMsg::Ident* temp = sender_;
  sender_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* AckConnectWorldResult::_internal_mutable_sender() {
  
  if (sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    sender_ = p;
  }
  return sender_;
}
inline ::NFMsg::Ident* AckConnectWorldResult::mutable_sender() {
  ::NFMsg::Ident* _msg = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:NFMsg.AckConnectWorldResult.sender)
  return _msg;
}
inline void AckConnectWorldResult::set_allocated_sender(::NFMsg::Ident* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_);
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender));
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckConnectWorldResult.sender)
}

// int32 login_id = 3;
inline void AckConnectWorldResult::clear_login_id() {
  login_id_ = 0;
}
inline int32_t AckConnectWorldResult::_internal_login_id() const {
  return login_id_;
}
inline int32_t AckConnectWorldResult::login_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckConnectWorldResult.login_id)
  return _internal_login_id();
}
inline void AckConnectWorldResult::_internal_set_login_id(int32_t value) {
  
  login_id_ = value;
}
inline void AckConnectWorldResult::set_login_id(int32_t value) {
  _internal_set_login_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.AckConnectWorldResult.login_id)
}

// bytes account = 4;
inline void AckConnectWorldResult::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& AckConnectWorldResult::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckConnectWorldResult.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckConnectWorldResult::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.AckConnectWorldResult.account)
}
inline std::string* AckConnectWorldResult::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.AckConnectWorldResult.account)
  return _s;
}
inline const std::string& AckConnectWorldResult::_internal_account() const {
  return account_.Get();
}
inline void AckConnectWorldResult::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* AckConnectWorldResult::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* AckConnectWorldResult::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.AckConnectWorldResult.account)
  return account_.Release();
}
inline void AckConnectWorldResult::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckConnectWorldResult.account)
}

// bytes world_ip = 5;
inline void AckConnectWorldResult::clear_world_ip() {
  world_ip_.ClearToEmpty();
}
inline const std::string& AckConnectWorldResult::world_ip() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckConnectWorldResult.world_ip)
  return _internal_world_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckConnectWorldResult::set_world_ip(ArgT0&& arg0, ArgT... args) {
 
 world_ip_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.AckConnectWorldResult.world_ip)
}
inline std::string* AckConnectWorldResult::mutable_world_ip() {
  std::string* _s = _internal_mutable_world_ip();
  // @@protoc_insertion_point(field_mutable:NFMsg.AckConnectWorldResult.world_ip)
  return _s;
}
inline const std::string& AckConnectWorldResult::_internal_world_ip() const {
  return world_ip_.Get();
}
inline void AckConnectWorldResult::_internal_set_world_ip(const std::string& value) {
  
  world_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* AckConnectWorldResult::_internal_mutable_world_ip() {
  
  return world_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* AckConnectWorldResult::release_world_ip() {
  // @@protoc_insertion_point(field_release:NFMsg.AckConnectWorldResult.world_ip)
  return world_ip_.Release();
}
inline void AckConnectWorldResult::set_allocated_world_ip(std::string* world_ip) {
  if (world_ip != nullptr) {
    
  } else {
    
  }
  world_ip_.SetAllocated(world_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (world_ip_.IsDefault()) {
    world_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckConnectWorldResult.world_ip)
}

// int32 world_port = 6;
inline void AckConnectWorldResult::clear_world_port() {
  world_port_ = 0;
}
inline int32_t AckConnectWorldResult::_internal_world_port() const {
  return world_port_;
}
inline int32_t AckConnectWorldResult::world_port() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckConnectWorldResult.world_port)
  return _internal_world_port();
}
inline void AckConnectWorldResult::_internal_set_world_port(int32_t value) {
  
  world_port_ = value;
}
inline void AckConnectWorldResult::set_world_port(int32_t value) {
  _internal_set_world_port(value);
  // @@protoc_insertion_point(field_set:NFMsg.AckConnectWorldResult.world_port)
}

// bytes world_key = 7;
inline void AckConnectWorldResult::clear_world_key() {
  world_key_.ClearToEmpty();
}
inline const std::string& AckConnectWorldResult::world_key() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckConnectWorldResult.world_key)
  return _internal_world_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckConnectWorldResult::set_world_key(ArgT0&& arg0, ArgT... args) {
 
 world_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.AckConnectWorldResult.world_key)
}
inline std::string* AckConnectWorldResult::mutable_world_key() {
  std::string* _s = _internal_mutable_world_key();
  // @@protoc_insertion_point(field_mutable:NFMsg.AckConnectWorldResult.world_key)
  return _s;
}
inline const std::string& AckConnectWorldResult::_internal_world_key() const {
  return world_key_.Get();
}
inline void AckConnectWorldResult::_internal_set_world_key(const std::string& value) {
  
  world_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AckConnectWorldResult::_internal_mutable_world_key() {
  
  return world_key_.Mutable(GetArenaForAllocation());
}
inline std::string* AckConnectWorldResult::release_world_key() {
  // @@protoc_insertion_point(field_release:NFMsg.AckConnectWorldResult.world_key)
  return world_key_.Release();
}
inline void AckConnectWorldResult::set_allocated_world_key(std::string* world_key) {
  if (world_key != nullptr) {
    
  } else {
    
  }
  world_key_.SetAllocated(world_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (world_key_.IsDefault()) {
    world_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckConnectWorldResult.world_key)
}

// -------------------------------------------------------------------

// ReqSelectServer

// int32 world_id = 1;
inline void ReqSelectServer::clear_world_id() {
  world_id_ = 0;
}
inline int32_t ReqSelectServer::_internal_world_id() const {
  return world_id_;
}
inline int32_t ReqSelectServer::world_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqSelectServer.world_id)
  return _internal_world_id();
}
inline void ReqSelectServer::_internal_set_world_id(int32_t value) {
  
  world_id_ = value;
}
inline void ReqSelectServer::set_world_id(int32_t value) {
  _internal_set_world_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqSelectServer.world_id)
}

// -------------------------------------------------------------------

// ReqKickFromWorld

// int32 world_id = 1;
inline void ReqKickFromWorld::clear_world_id() {
  world_id_ = 0;
}
inline int32_t ReqKickFromWorld::_internal_world_id() const {
  return world_id_;
}
inline int32_t ReqKickFromWorld::world_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqKickFromWorld.world_id)
  return _internal_world_id();
}
inline void ReqKickFromWorld::_internal_set_world_id(int32_t value) {
  
  world_id_ = value;
}
inline void ReqKickFromWorld::set_world_id(int32_t value) {
  _internal_set_world_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqKickFromWorld.world_id)
}

// bytes account = 2;
inline void ReqKickFromWorld::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqKickFromWorld::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqKickFromWorld.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqKickFromWorld::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqKickFromWorld.account)
}
inline std::string* ReqKickFromWorld::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqKickFromWorld.account)
  return _s;
}
inline const std::string& ReqKickFromWorld::_internal_account() const {
  return account_.Get();
}
inline void ReqKickFromWorld::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqKickFromWorld::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqKickFromWorld::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqKickFromWorld.account)
  return account_.Release();
}
inline void ReqKickFromWorld::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqKickFromWorld.account)
}

// -------------------------------------------------------------------

// ReqRoleList

// int32 game_id = 1;
inline void ReqRoleList::clear_game_id() {
  game_id_ = 0;
}
inline int32_t ReqRoleList::_internal_game_id() const {
  return game_id_;
}
inline int32_t ReqRoleList::game_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqRoleList.game_id)
  return _internal_game_id();
}
inline void ReqRoleList::_internal_set_game_id(int32_t value) {
  
  game_id_ = value;
}
inline void ReqRoleList::set_game_id(int32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqRoleList.game_id)
}

// bytes account = 2;
inline void ReqRoleList::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqRoleList::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqRoleList.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqRoleList::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqRoleList.account)
}
inline std::string* ReqRoleList::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqRoleList.account)
  return _s;
}
inline const std::string& ReqRoleList::_internal_account() const {
  return account_.Get();
}
inline void ReqRoleList::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqRoleList::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqRoleList::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqRoleList.account)
  return account_.Release();
}
inline void ReqRoleList::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqRoleList.account)
}

// -------------------------------------------------------------------

// RoleLiteInfo

// .NFMsg.Ident id = 1;
inline bool RoleLiteInfo::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool RoleLiteInfo::has_id() const {
  return _internal_has_id();
}
inline const ::NFMsg::Ident& RoleLiteInfo::_internal_id() const {
  const ::NFMsg::Ident* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& RoleLiteInfo::id() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.id)
  return _internal_id();
}
inline void RoleLiteInfo::unsafe_arena_set_allocated_id(
    ::NFMsg::Ident* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.RoleLiteInfo.id)
}
inline ::NFMsg::Ident* RoleLiteInfo::release_id() {
  
  ::NFMsg::Ident* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* RoleLiteInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleLiteInfo.id)
  
  ::NFMsg::Ident* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* RoleLiteInfo::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::NFMsg::Ident* RoleLiteInfo::mutable_id() {
  ::NFMsg::Ident* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleLiteInfo.id)
  return _msg;
}
inline void RoleLiteInfo::set_allocated_id(::NFMsg::Ident* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleLiteInfo.id)
}

// int32 career = 2;
inline void RoleLiteInfo::clear_career() {
  career_ = 0;
}
inline int32_t RoleLiteInfo::_internal_career() const {
  return career_;
}
inline int32_t RoleLiteInfo::career() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.career)
  return _internal_career();
}
inline void RoleLiteInfo::_internal_set_career(int32_t value) {
  
  career_ = value;
}
inline void RoleLiteInfo::set_career(int32_t value) {
  _internal_set_career(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.career)
}

// int32 sex = 3;
inline void RoleLiteInfo::clear_sex() {
  sex_ = 0;
}
inline int32_t RoleLiteInfo::_internal_sex() const {
  return sex_;
}
inline int32_t RoleLiteInfo::sex() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.sex)
  return _internal_sex();
}
inline void RoleLiteInfo::_internal_set_sex(int32_t value) {
  
  sex_ = value;
}
inline void RoleLiteInfo::set_sex(int32_t value) {
  _internal_set_sex(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.sex)
}

// int32 race = 4;
inline void RoleLiteInfo::clear_race() {
  race_ = 0;
}
inline int32_t RoleLiteInfo::_internal_race() const {
  return race_;
}
inline int32_t RoleLiteInfo::race() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.race)
  return _internal_race();
}
inline void RoleLiteInfo::_internal_set_race(int32_t value) {
  
  race_ = value;
}
inline void RoleLiteInfo::set_race(int32_t value) {
  _internal_set_race(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.race)
}

// bytes noob_name = 5;
inline void RoleLiteInfo::clear_noob_name() {
  noob_name_.ClearToEmpty();
}
inline const std::string& RoleLiteInfo::noob_name() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.noob_name)
  return _internal_noob_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleLiteInfo::set_noob_name(ArgT0&& arg0, ArgT... args) {
 
 noob_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.noob_name)
}
inline std::string* RoleLiteInfo::mutable_noob_name() {
  std::string* _s = _internal_mutable_noob_name();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleLiteInfo.noob_name)
  return _s;
}
inline const std::string& RoleLiteInfo::_internal_noob_name() const {
  return noob_name_.Get();
}
inline void RoleLiteInfo::_internal_set_noob_name(const std::string& value) {
  
  noob_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoleLiteInfo::_internal_mutable_noob_name() {
  
  return noob_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoleLiteInfo::release_noob_name() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleLiteInfo.noob_name)
  return noob_name_.Release();
}
inline void RoleLiteInfo::set_allocated_noob_name(std::string* noob_name) {
  if (noob_name != nullptr) {
    
  } else {
    
  }
  noob_name_.SetAllocated(noob_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (noob_name_.IsDefault()) {
    noob_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleLiteInfo.noob_name)
}

// int32 game_id = 6;
inline void RoleLiteInfo::clear_game_id() {
  game_id_ = 0;
}
inline int32_t RoleLiteInfo::_internal_game_id() const {
  return game_id_;
}
inline int32_t RoleLiteInfo::game_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.game_id)
  return _internal_game_id();
}
inline void RoleLiteInfo::_internal_set_game_id(int32_t value) {
  
  game_id_ = value;
}
inline void RoleLiteInfo::set_game_id(int32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.game_id)
}

// int32 role_level = 7;
inline void RoleLiteInfo::clear_role_level() {
  role_level_ = 0;
}
inline int32_t RoleLiteInfo::_internal_role_level() const {
  return role_level_;
}
inline int32_t RoleLiteInfo::role_level() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.role_level)
  return _internal_role_level();
}
inline void RoleLiteInfo::_internal_set_role_level(int32_t value) {
  
  role_level_ = value;
}
inline void RoleLiteInfo::set_role_level(int32_t value) {
  _internal_set_role_level(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.role_level)
}

// int32 delete_time = 8;
inline void RoleLiteInfo::clear_delete_time() {
  delete_time_ = 0;
}
inline int32_t RoleLiteInfo::_internal_delete_time() const {
  return delete_time_;
}
inline int32_t RoleLiteInfo::delete_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.delete_time)
  return _internal_delete_time();
}
inline void RoleLiteInfo::_internal_set_delete_time(int32_t value) {
  
  delete_time_ = value;
}
inline void RoleLiteInfo::set_delete_time(int32_t value) {
  _internal_set_delete_time(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.delete_time)
}

// int32 reg_time = 9;
inline void RoleLiteInfo::clear_reg_time() {
  reg_time_ = 0;
}
inline int32_t RoleLiteInfo::_internal_reg_time() const {
  return reg_time_;
}
inline int32_t RoleLiteInfo::reg_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.reg_time)
  return _internal_reg_time();
}
inline void RoleLiteInfo::_internal_set_reg_time(int32_t value) {
  
  reg_time_ = value;
}
inline void RoleLiteInfo::set_reg_time(int32_t value) {
  _internal_set_reg_time(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.reg_time)
}

// int32 last_offline_time = 10;
inline void RoleLiteInfo::clear_last_offline_time() {
  last_offline_time_ = 0;
}
inline int32_t RoleLiteInfo::_internal_last_offline_time() const {
  return last_offline_time_;
}
inline int32_t RoleLiteInfo::last_offline_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.last_offline_time)
  return _internal_last_offline_time();
}
inline void RoleLiteInfo::_internal_set_last_offline_time(int32_t value) {
  
  last_offline_time_ = value;
}
inline void RoleLiteInfo::set_last_offline_time(int32_t value) {
  _internal_set_last_offline_time(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.last_offline_time)
}

// int32 last_offline_ip = 11;
inline void RoleLiteInfo::clear_last_offline_ip() {
  last_offline_ip_ = 0;
}
inline int32_t RoleLiteInfo::_internal_last_offline_ip() const {
  return last_offline_ip_;
}
inline int32_t RoleLiteInfo::last_offline_ip() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.last_offline_ip)
  return _internal_last_offline_ip();
}
inline void RoleLiteInfo::_internal_set_last_offline_ip(int32_t value) {
  
  last_offline_ip_ = value;
}
inline void RoleLiteInfo::set_last_offline_ip(int32_t value) {
  _internal_set_last_offline_ip(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.last_offline_ip)
}

// bytes view_record = 12;
inline void RoleLiteInfo::clear_view_record() {
  view_record_.ClearToEmpty();
}
inline const std::string& RoleLiteInfo::view_record() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleLiteInfo.view_record)
  return _internal_view_record();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleLiteInfo::set_view_record(ArgT0&& arg0, ArgT... args) {
 
 view_record_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.RoleLiteInfo.view_record)
}
inline std::string* RoleLiteInfo::mutable_view_record() {
  std::string* _s = _internal_mutable_view_record();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleLiteInfo.view_record)
  return _s;
}
inline const std::string& RoleLiteInfo::_internal_view_record() const {
  return view_record_.Get();
}
inline void RoleLiteInfo::_internal_set_view_record(const std::string& value) {
  
  view_record_.Set(value, GetArenaForAllocation());
}
inline std::string* RoleLiteInfo::_internal_mutable_view_record() {
  
  return view_record_.Mutable(GetArenaForAllocation());
}
inline std::string* RoleLiteInfo::release_view_record() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleLiteInfo.view_record)
  return view_record_.Release();
}
inline void RoleLiteInfo::set_allocated_view_record(std::string* view_record) {
  if (view_record != nullptr) {
    
  } else {
    
  }
  view_record_.SetAllocated(view_record, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_record_.IsDefault()) {
    view_record_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleLiteInfo.view_record)
}

// -------------------------------------------------------------------

// AckRoleLiteInfoList

// repeated .NFMsg.RoleLiteInfo char_data = 1;
inline int AckRoleLiteInfoList::_internal_char_data_size() const {
  return char_data_.size();
}
inline int AckRoleLiteInfoList::char_data_size() const {
  return _internal_char_data_size();
}
inline void AckRoleLiteInfoList::clear_char_data() {
  char_data_.Clear();
}
inline ::NFMsg::RoleLiteInfo* AckRoleLiteInfoList::mutable_char_data(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.AckRoleLiteInfoList.char_data)
  return char_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::RoleLiteInfo >*
AckRoleLiteInfoList::mutable_char_data() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.AckRoleLiteInfoList.char_data)
  return &char_data_;
}
inline const ::NFMsg::RoleLiteInfo& AckRoleLiteInfoList::_internal_char_data(int index) const {
  return char_data_.Get(index);
}
inline const ::NFMsg::RoleLiteInfo& AckRoleLiteInfoList::char_data(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.AckRoleLiteInfoList.char_data)
  return _internal_char_data(index);
}
inline ::NFMsg::RoleLiteInfo* AckRoleLiteInfoList::_internal_add_char_data() {
  return char_data_.Add();
}
inline ::NFMsg::RoleLiteInfo* AckRoleLiteInfoList::add_char_data() {
  ::NFMsg::RoleLiteInfo* _add = _internal_add_char_data();
  // @@protoc_insertion_point(field_add:NFMsg.AckRoleLiteInfoList.char_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::RoleLiteInfo >&
AckRoleLiteInfoList::char_data() const {
  // @@protoc_insertion_point(field_list:NFMsg.AckRoleLiteInfoList.char_data)
  return char_data_;
}

// bytes account = 2;
inline void AckRoleLiteInfoList::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& AckRoleLiteInfoList::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckRoleLiteInfoList.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckRoleLiteInfoList::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.AckRoleLiteInfoList.account)
}
inline std::string* AckRoleLiteInfoList::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.AckRoleLiteInfoList.account)
  return _s;
}
inline const std::string& AckRoleLiteInfoList::_internal_account() const {
  return account_.Get();
}
inline void AckRoleLiteInfoList::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* AckRoleLiteInfoList::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* AckRoleLiteInfoList::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.AckRoleLiteInfoList.account)
  return account_.Release();
}
inline void AckRoleLiteInfoList::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckRoleLiteInfoList.account)
}

// -------------------------------------------------------------------

// ReqCreateRole

// bytes account = 1;
inline void ReqCreateRole::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqCreateRole::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqCreateRole.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqCreateRole::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqCreateRole.account)
}
inline std::string* ReqCreateRole::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqCreateRole.account)
  return _s;
}
inline const std::string& ReqCreateRole::_internal_account() const {
  return account_.Get();
}
inline void ReqCreateRole::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqCreateRole::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqCreateRole::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqCreateRole.account)
  return account_.Release();
}
inline void ReqCreateRole::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqCreateRole.account)
}

// int32 career = 2;
inline void ReqCreateRole::clear_career() {
  career_ = 0;
}
inline int32_t ReqCreateRole::_internal_career() const {
  return career_;
}
inline int32_t ReqCreateRole::career() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqCreateRole.career)
  return _internal_career();
}
inline void ReqCreateRole::_internal_set_career(int32_t value) {
  
  career_ = value;
}
inline void ReqCreateRole::set_career(int32_t value) {
  _internal_set_career(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqCreateRole.career)
}

// int32 sex = 3;
inline void ReqCreateRole::clear_sex() {
  sex_ = 0;
}
inline int32_t ReqCreateRole::_internal_sex() const {
  return sex_;
}
inline int32_t ReqCreateRole::sex() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqCreateRole.sex)
  return _internal_sex();
}
inline void ReqCreateRole::_internal_set_sex(int32_t value) {
  
  sex_ = value;
}
inline void ReqCreateRole::set_sex(int32_t value) {
  _internal_set_sex(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqCreateRole.sex)
}

// int32 race = 4;
inline void ReqCreateRole::clear_race() {
  race_ = 0;
}
inline int32_t ReqCreateRole::_internal_race() const {
  return race_;
}
inline int32_t ReqCreateRole::race() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqCreateRole.race)
  return _internal_race();
}
inline void ReqCreateRole::_internal_set_race(int32_t value) {
  
  race_ = value;
}
inline void ReqCreateRole::set_race(int32_t value) {
  _internal_set_race(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqCreateRole.race)
}

// bytes noob_name = 5;
inline void ReqCreateRole::clear_noob_name() {
  noob_name_.ClearToEmpty();
}
inline const std::string& ReqCreateRole::noob_name() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqCreateRole.noob_name)
  return _internal_noob_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqCreateRole::set_noob_name(ArgT0&& arg0, ArgT... args) {
 
 noob_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqCreateRole.noob_name)
}
inline std::string* ReqCreateRole::mutable_noob_name() {
  std::string* _s = _internal_mutable_noob_name();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqCreateRole.noob_name)
  return _s;
}
inline const std::string& ReqCreateRole::_internal_noob_name() const {
  return noob_name_.Get();
}
inline void ReqCreateRole::_internal_set_noob_name(const std::string& value) {
  
  noob_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqCreateRole::_internal_mutable_noob_name() {
  
  return noob_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqCreateRole::release_noob_name() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqCreateRole.noob_name)
  return noob_name_.Release();
}
inline void ReqCreateRole::set_allocated_noob_name(std::string* noob_name) {
  if (noob_name != nullptr) {
    
  } else {
    
  }
  noob_name_.SetAllocated(noob_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (noob_name_.IsDefault()) {
    noob_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqCreateRole.noob_name)
}

// -------------------------------------------------------------------

// ReqDeleteRole

// bytes account = 1;
inline void ReqDeleteRole::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqDeleteRole::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqDeleteRole.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDeleteRole::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqDeleteRole.account)
}
inline std::string* ReqDeleteRole::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqDeleteRole.account)
  return _s;
}
inline const std::string& ReqDeleteRole::_internal_account() const {
  return account_.Get();
}
inline void ReqDeleteRole::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDeleteRole::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDeleteRole::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqDeleteRole.account)
  return account_.Release();
}
inline void ReqDeleteRole::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqDeleteRole.account)
}

// bytes name = 2;
inline void ReqDeleteRole::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ReqDeleteRole::name() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqDeleteRole.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDeleteRole::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqDeleteRole.name)
}
inline std::string* ReqDeleteRole::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqDeleteRole.name)
  return _s;
}
inline const std::string& ReqDeleteRole::_internal_name() const {
  return name_.Get();
}
inline void ReqDeleteRole::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDeleteRole::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDeleteRole::release_name() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqDeleteRole.name)
  return name_.Release();
}
inline void ReqDeleteRole::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqDeleteRole.name)
}

// int32 game_id = 3;
inline void ReqDeleteRole::clear_game_id() {
  game_id_ = 0;
}
inline int32_t ReqDeleteRole::_internal_game_id() const {
  return game_id_;
}
inline int32_t ReqDeleteRole::game_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqDeleteRole.game_id)
  return _internal_game_id();
}
inline void ReqDeleteRole::_internal_set_game_id(int32_t value) {
  
  game_id_ = value;
}
inline void ReqDeleteRole::set_game_id(int32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqDeleteRole.game_id)
}

// -------------------------------------------------------------------

// ReqRecoverRole

// bytes account = 1;
inline void ReqRecoverRole::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqRecoverRole::account() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqRecoverRole.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqRecoverRole::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqRecoverRole.account)
}
inline std::string* ReqRecoverRole::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqRecoverRole.account)
  return _s;
}
inline const std::string& ReqRecoverRole::_internal_account() const {
  return account_.Get();
}
inline void ReqRecoverRole::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqRecoverRole::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqRecoverRole::release_account() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqRecoverRole.account)
  return account_.Release();
}
inline void ReqRecoverRole::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqRecoverRole.account)
}

// bytes name = 2;
inline void ReqRecoverRole::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ReqRecoverRole::name() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqRecoverRole.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqRecoverRole::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.ReqRecoverRole.name)
}
inline std::string* ReqRecoverRole::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqRecoverRole.name)
  return _s;
}
inline const std::string& ReqRecoverRole::_internal_name() const {
  return name_.Get();
}
inline void ReqRecoverRole::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqRecoverRole::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqRecoverRole::release_name() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqRecoverRole.name)
  return name_.Release();
}
inline void ReqRecoverRole::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqRecoverRole.name)
}

// int32 game_id = 3;
inline void ReqRecoverRole::clear_game_id() {
  game_id_ = 0;
}
inline int32_t ReqRecoverRole::_internal_game_id() const {
  return game_id_;
}
inline int32_t ReqRecoverRole::game_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqRecoverRole.game_id)
  return _internal_game_id();
}
inline void ReqRecoverRole::_internal_set_game_id(int32_t value) {
  
  game_id_ = value;
}
inline void ReqRecoverRole::set_game_id(int32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqRecoverRole.game_id)
}

// -------------------------------------------------------------------

// ServerHeartBeat

// int32 count = 1;
inline void ServerHeartBeat::clear_count() {
  count_ = 0;
}
inline int32_t ServerHeartBeat::_internal_count() const {
  return count_;
}
inline int32_t ServerHeartBeat::count() const {
  // @@protoc_insertion_point(field_get:NFMsg.ServerHeartBeat.count)
  return _internal_count();
}
inline void ServerHeartBeat::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void ServerHeartBeat::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:NFMsg.ServerHeartBeat.count)
}

// -------------------------------------------------------------------

// RoleOnlineNotify

// .NFMsg.Ident self = 1;
inline bool RoleOnlineNotify::_internal_has_self() const {
  return this != internal_default_instance() && self_ != nullptr;
}
inline bool RoleOnlineNotify::has_self() const {
  return _internal_has_self();
}
inline const ::NFMsg::Ident& RoleOnlineNotify::_internal_self() const {
  const ::NFMsg::Ident* p = self_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& RoleOnlineNotify::self() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.self)
  return _internal_self();
}
inline void RoleOnlineNotify::unsafe_arena_set_allocated_self(
    ::NFMsg::Ident* self) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(self_);
  }
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.RoleOnlineNotify.self)
}
inline ::NFMsg::Ident* RoleOnlineNotify::release_self() {
  
  ::NFMsg::Ident* temp = self_;
  self_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* RoleOnlineNotify::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleOnlineNotify.self)
  
  ::NFMsg::Ident* temp = self_;
  self_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* RoleOnlineNotify::_internal_mutable_self() {
  
  if (self_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    self_ = p;
  }
  return self_;
}
inline ::NFMsg::Ident* RoleOnlineNotify::mutable_self() {
  ::NFMsg::Ident* _msg = _internal_mutable_self();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOnlineNotify.self)
  return _msg;
}
inline void RoleOnlineNotify::set_allocated_self(::NFMsg::Ident* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(self_);
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(self));
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleOnlineNotify.self)
}

// int32 game = 3;
inline void RoleOnlineNotify::clear_game() {
  game_ = 0;
}
inline int32_t RoleOnlineNotify::_internal_game() const {
  return game_;
}
inline int32_t RoleOnlineNotify::game() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.game)
  return _internal_game();
}
inline void RoleOnlineNotify::_internal_set_game(int32_t value) {
  
  game_ = value;
}
inline void RoleOnlineNotify::set_game(int32_t value) {
  _internal_set_game(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleOnlineNotify.game)
}

// int32 proxy = 4;
inline void RoleOnlineNotify::clear_proxy() {
  proxy_ = 0;
}
inline int32_t RoleOnlineNotify::_internal_proxy() const {
  return proxy_;
}
inline int32_t RoleOnlineNotify::proxy() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.proxy)
  return _internal_proxy();
}
inline void RoleOnlineNotify::_internal_set_proxy(int32_t value) {
  
  proxy_ = value;
}
inline void RoleOnlineNotify::set_proxy(int32_t value) {
  _internal_set_proxy(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleOnlineNotify.proxy)
}

// bytes name = 5;
inline void RoleOnlineNotify::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RoleOnlineNotify::name() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleOnlineNotify::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NFMsg.RoleOnlineNotify.name)
}
inline std::string* RoleOnlineNotify::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOnlineNotify.name)
  return _s;
}
inline const std::string& RoleOnlineNotify::_internal_name() const {
  return name_.Get();
}
inline void RoleOnlineNotify::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoleOnlineNotify::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoleOnlineNotify::release_name() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleOnlineNotify.name)
  return name_.Release();
}
inline void RoleOnlineNotify::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleOnlineNotify.name)
}

// int32 bp = 6;
inline void RoleOnlineNotify::clear_bp() {
  bp_ = 0;
}
inline int32_t RoleOnlineNotify::_internal_bp() const {
  return bp_;
}
inline int32_t RoleOnlineNotify::bp() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.bp)
  return _internal_bp();
}
inline void RoleOnlineNotify::_internal_set_bp(int32_t value) {
  
  bp_ = value;
}
inline void RoleOnlineNotify::set_bp(int32_t value) {
  _internal_set_bp(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleOnlineNotify.bp)
}

// repeated .NFMsg.PropertyInt property_int_list = 20;
inline int RoleOnlineNotify::_internal_property_int_list_size() const {
  return property_int_list_.size();
}
inline int RoleOnlineNotify::property_int_list_size() const {
  return _internal_property_int_list_size();
}
inline ::NFMsg::PropertyInt* RoleOnlineNotify::mutable_property_int_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOnlineNotify.property_int_list)
  return property_int_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyInt >*
RoleOnlineNotify::mutable_property_int_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.RoleOnlineNotify.property_int_list)
  return &property_int_list_;
}
inline const ::NFMsg::PropertyInt& RoleOnlineNotify::_internal_property_int_list(int index) const {
  return property_int_list_.Get(index);
}
inline const ::NFMsg::PropertyInt& RoleOnlineNotify::property_int_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.property_int_list)
  return _internal_property_int_list(index);
}
inline ::NFMsg::PropertyInt* RoleOnlineNotify::_internal_add_property_int_list() {
  return property_int_list_.Add();
}
inline ::NFMsg::PropertyInt* RoleOnlineNotify::add_property_int_list() {
  ::NFMsg::PropertyInt* _add = _internal_add_property_int_list();
  // @@protoc_insertion_point(field_add:NFMsg.RoleOnlineNotify.property_int_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyInt >&
RoleOnlineNotify::property_int_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.RoleOnlineNotify.property_int_list)
  return property_int_list_;
}

// repeated .NFMsg.PropertyFloat property_float_list = 21;
inline int RoleOnlineNotify::_internal_property_float_list_size() const {
  return property_float_list_.size();
}
inline int RoleOnlineNotify::property_float_list_size() const {
  return _internal_property_float_list_size();
}
inline ::NFMsg::PropertyFloat* RoleOnlineNotify::mutable_property_float_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOnlineNotify.property_float_list)
  return property_float_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyFloat >*
RoleOnlineNotify::mutable_property_float_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.RoleOnlineNotify.property_float_list)
  return &property_float_list_;
}
inline const ::NFMsg::PropertyFloat& RoleOnlineNotify::_internal_property_float_list(int index) const {
  return property_float_list_.Get(index);
}
inline const ::NFMsg::PropertyFloat& RoleOnlineNotify::property_float_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.property_float_list)
  return _internal_property_float_list(index);
}
inline ::NFMsg::PropertyFloat* RoleOnlineNotify::_internal_add_property_float_list() {
  return property_float_list_.Add();
}
inline ::NFMsg::PropertyFloat* RoleOnlineNotify::add_property_float_list() {
  ::NFMsg::PropertyFloat* _add = _internal_add_property_float_list();
  // @@protoc_insertion_point(field_add:NFMsg.RoleOnlineNotify.property_float_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyFloat >&
RoleOnlineNotify::property_float_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.RoleOnlineNotify.property_float_list)
  return property_float_list_;
}

// repeated .NFMsg.PropertyString property_string_list = 22;
inline int RoleOnlineNotify::_internal_property_string_list_size() const {
  return property_string_list_.size();
}
inline int RoleOnlineNotify::property_string_list_size() const {
  return _internal_property_string_list_size();
}
inline ::NFMsg::PropertyString* RoleOnlineNotify::mutable_property_string_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOnlineNotify.property_string_list)
  return property_string_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyString >*
RoleOnlineNotify::mutable_property_string_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.RoleOnlineNotify.property_string_list)
  return &property_string_list_;
}
inline const ::NFMsg::PropertyString& RoleOnlineNotify::_internal_property_string_list(int index) const {
  return property_string_list_.Get(index);
}
inline const ::NFMsg::PropertyString& RoleOnlineNotify::property_string_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.property_string_list)
  return _internal_property_string_list(index);
}
inline ::NFMsg::PropertyString* RoleOnlineNotify::_internal_add_property_string_list() {
  return property_string_list_.Add();
}
inline ::NFMsg::PropertyString* RoleOnlineNotify::add_property_string_list() {
  ::NFMsg::PropertyString* _add = _internal_add_property_string_list();
  // @@protoc_insertion_point(field_add:NFMsg.RoleOnlineNotify.property_string_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyString >&
RoleOnlineNotify::property_string_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.RoleOnlineNotify.property_string_list)
  return property_string_list_;
}

// repeated .NFMsg.PropertyObject property_object_list = 23;
inline int RoleOnlineNotify::_internal_property_object_list_size() const {
  return property_object_list_.size();
}
inline int RoleOnlineNotify::property_object_list_size() const {
  return _internal_property_object_list_size();
}
inline ::NFMsg::PropertyObject* RoleOnlineNotify::mutable_property_object_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOnlineNotify.property_object_list)
  return property_object_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyObject >*
RoleOnlineNotify::mutable_property_object_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.RoleOnlineNotify.property_object_list)
  return &property_object_list_;
}
inline const ::NFMsg::PropertyObject& RoleOnlineNotify::_internal_property_object_list(int index) const {
  return property_object_list_.Get(index);
}
inline const ::NFMsg::PropertyObject& RoleOnlineNotify::property_object_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.property_object_list)
  return _internal_property_object_list(index);
}
inline ::NFMsg::PropertyObject* RoleOnlineNotify::_internal_add_property_object_list() {
  return property_object_list_.Add();
}
inline ::NFMsg::PropertyObject* RoleOnlineNotify::add_property_object_list() {
  ::NFMsg::PropertyObject* _add = _internal_add_property_object_list();
  // @@protoc_insertion_point(field_add:NFMsg.RoleOnlineNotify.property_object_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyObject >&
RoleOnlineNotify::property_object_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.RoleOnlineNotify.property_object_list)
  return property_object_list_;
}

// repeated .NFMsg.PropertyVector2 property_vector2_list = 24;
inline int RoleOnlineNotify::_internal_property_vector2_list_size() const {
  return property_vector2_list_.size();
}
inline int RoleOnlineNotify::property_vector2_list_size() const {
  return _internal_property_vector2_list_size();
}
inline ::NFMsg::PropertyVector2* RoleOnlineNotify::mutable_property_vector2_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOnlineNotify.property_vector2_list)
  return property_vector2_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector2 >*
RoleOnlineNotify::mutable_property_vector2_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.RoleOnlineNotify.property_vector2_list)
  return &property_vector2_list_;
}
inline const ::NFMsg::PropertyVector2& RoleOnlineNotify::_internal_property_vector2_list(int index) const {
  return property_vector2_list_.Get(index);
}
inline const ::NFMsg::PropertyVector2& RoleOnlineNotify::property_vector2_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.property_vector2_list)
  return _internal_property_vector2_list(index);
}
inline ::NFMsg::PropertyVector2* RoleOnlineNotify::_internal_add_property_vector2_list() {
  return property_vector2_list_.Add();
}
inline ::NFMsg::PropertyVector2* RoleOnlineNotify::add_property_vector2_list() {
  ::NFMsg::PropertyVector2* _add = _internal_add_property_vector2_list();
  // @@protoc_insertion_point(field_add:NFMsg.RoleOnlineNotify.property_vector2_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector2 >&
RoleOnlineNotify::property_vector2_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.RoleOnlineNotify.property_vector2_list)
  return property_vector2_list_;
}

// repeated .NFMsg.PropertyVector3 property_vector3_list = 25;
inline int RoleOnlineNotify::_internal_property_vector3_list_size() const {
  return property_vector3_list_.size();
}
inline int RoleOnlineNotify::property_vector3_list_size() const {
  return _internal_property_vector3_list_size();
}
inline ::NFMsg::PropertyVector3* RoleOnlineNotify::mutable_property_vector3_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOnlineNotify.property_vector3_list)
  return property_vector3_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector3 >*
RoleOnlineNotify::mutable_property_vector3_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.RoleOnlineNotify.property_vector3_list)
  return &property_vector3_list_;
}
inline const ::NFMsg::PropertyVector3& RoleOnlineNotify::_internal_property_vector3_list(int index) const {
  return property_vector3_list_.Get(index);
}
inline const ::NFMsg::PropertyVector3& RoleOnlineNotify::property_vector3_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOnlineNotify.property_vector3_list)
  return _internal_property_vector3_list(index);
}
inline ::NFMsg::PropertyVector3* RoleOnlineNotify::_internal_add_property_vector3_list() {
  return property_vector3_list_.Add();
}
inline ::NFMsg::PropertyVector3* RoleOnlineNotify::add_property_vector3_list() {
  ::NFMsg::PropertyVector3* _add = _internal_add_property_vector3_list();
  // @@protoc_insertion_point(field_add:NFMsg.RoleOnlineNotify.property_vector3_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NFMsg::PropertyVector3 >&
RoleOnlineNotify::property_vector3_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.RoleOnlineNotify.property_vector3_list)
  return property_vector3_list_;
}

// -------------------------------------------------------------------

// RoleOfflineNotify

// .NFMsg.Ident self = 1;
inline bool RoleOfflineNotify::_internal_has_self() const {
  return this != internal_default_instance() && self_ != nullptr;
}
inline bool RoleOfflineNotify::has_self() const {
  return _internal_has_self();
}
inline const ::NFMsg::Ident& RoleOfflineNotify::_internal_self() const {
  const ::NFMsg::Ident* p = self_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& RoleOfflineNotify::self() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOfflineNotify.self)
  return _internal_self();
}
inline void RoleOfflineNotify::unsafe_arena_set_allocated_self(
    ::NFMsg::Ident* self) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(self_);
  }
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.RoleOfflineNotify.self)
}
inline ::NFMsg::Ident* RoleOfflineNotify::release_self() {
  
  ::NFMsg::Ident* temp = self_;
  self_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* RoleOfflineNotify::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleOfflineNotify.self)
  
  ::NFMsg::Ident* temp = self_;
  self_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* RoleOfflineNotify::_internal_mutable_self() {
  
  if (self_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    self_ = p;
  }
  return self_;
}
inline ::NFMsg::Ident* RoleOfflineNotify::mutable_self() {
  ::NFMsg::Ident* _msg = _internal_mutable_self();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOfflineNotify.self)
  return _msg;
}
inline void RoleOfflineNotify::set_allocated_self(::NFMsg::Ident* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(self_);
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(self));
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleOfflineNotify.self)
}

// .NFMsg.Ident clan = 2;
inline bool RoleOfflineNotify::_internal_has_clan() const {
  return this != internal_default_instance() && clan_ != nullptr;
}
inline bool RoleOfflineNotify::has_clan() const {
  return _internal_has_clan();
}
inline const ::NFMsg::Ident& RoleOfflineNotify::_internal_clan() const {
  const ::NFMsg::Ident* p = clan_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& RoleOfflineNotify::clan() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOfflineNotify.clan)
  return _internal_clan();
}
inline void RoleOfflineNotify::unsafe_arena_set_allocated_clan(
    ::NFMsg::Ident* clan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clan_);
  }
  clan_ = clan;
  if (clan) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.RoleOfflineNotify.clan)
}
inline ::NFMsg::Ident* RoleOfflineNotify::release_clan() {
  
  ::NFMsg::Ident* temp = clan_;
  clan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* RoleOfflineNotify::unsafe_arena_release_clan() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleOfflineNotify.clan)
  
  ::NFMsg::Ident* temp = clan_;
  clan_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* RoleOfflineNotify::_internal_mutable_clan() {
  
  if (clan_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    clan_ = p;
  }
  return clan_;
}
inline ::NFMsg::Ident* RoleOfflineNotify::mutable_clan() {
  ::NFMsg::Ident* _msg = _internal_mutable_clan();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleOfflineNotify.clan)
  return _msg;
}
inline void RoleOfflineNotify::set_allocated_clan(::NFMsg::Ident* clan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(clan_);
  }
  if (clan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clan));
    if (message_arena != submessage_arena) {
      clan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clan, submessage_arena);
    }
    
  } else {
    
  }
  clan_ = clan;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleOfflineNotify.clan)
}

// int32 game = 3;
inline void RoleOfflineNotify::clear_game() {
  game_ = 0;
}
inline int32_t RoleOfflineNotify::_internal_game() const {
  return game_;
}
inline int32_t RoleOfflineNotify::game() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOfflineNotify.game)
  return _internal_game();
}
inline void RoleOfflineNotify::_internal_set_game(int32_t value) {
  
  game_ = value;
}
inline void RoleOfflineNotify::set_game(int32_t value) {
  _internal_set_game(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleOfflineNotify.game)
}

// int32 proxy = 4;
inline void RoleOfflineNotify::clear_proxy() {
  proxy_ = 0;
}
inline int32_t RoleOfflineNotify::_internal_proxy() const {
  return proxy_;
}
inline int32_t RoleOfflineNotify::proxy() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleOfflineNotify.proxy)
  return _internal_proxy();
}
inline void RoleOfflineNotify::_internal_set_proxy(int32_t value) {
  
  proxy_ = value;
}
inline void RoleOfflineNotify::set_proxy(int32_t value) {
  _internal_set_proxy(value);
  // @@protoc_insertion_point(field_set:NFMsg.RoleOfflineNotify.proxy)
}

// -------------------------------------------------------------------

// RoleDataPack

// .NFMsg.Ident id = 1;
inline bool RoleDataPack::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool RoleDataPack::has_id() const {
  return _internal_has_id();
}
inline const ::NFMsg::Ident& RoleDataPack::_internal_id() const {
  const ::NFMsg::Ident* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::Ident&>(
      ::NFMsg::_Ident_default_instance_);
}
inline const ::NFMsg::Ident& RoleDataPack::id() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleDataPack.id)
  return _internal_id();
}
inline void RoleDataPack::unsafe_arena_set_allocated_id(
    ::NFMsg::Ident* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.RoleDataPack.id)
}
inline ::NFMsg::Ident* RoleDataPack::release_id() {
  
  ::NFMsg::Ident* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::Ident* RoleDataPack::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleDataPack.id)
  
  ::NFMsg::Ident* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::NFMsg::Ident* RoleDataPack::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::NFMsg::Ident* RoleDataPack::mutable_id() {
  ::NFMsg::Ident* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleDataPack.id)
  return _msg;
}
inline void RoleDataPack::set_allocated_id(::NFMsg::Ident* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleDataPack.id)
}

// .NFMsg.ObjectPropertyList property = 2;
inline bool RoleDataPack::_internal_has_property() const {
  return this != internal_default_instance() && property_ != nullptr;
}
inline bool RoleDataPack::has_property() const {
  return _internal_has_property();
}
inline const ::NFMsg::ObjectPropertyList& RoleDataPack::_internal_property() const {
  const ::NFMsg::ObjectPropertyList* p = property_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::ObjectPropertyList&>(
      ::NFMsg::_ObjectPropertyList_default_instance_);
}
inline const ::NFMsg::ObjectPropertyList& RoleDataPack::property() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleDataPack.property)
  return _internal_property();
}
inline void RoleDataPack::unsafe_arena_set_allocated_property(
    ::NFMsg::ObjectPropertyList* property) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(property_);
  }
  property_ = property;
  if (property) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.RoleDataPack.property)
}
inline ::NFMsg::ObjectPropertyList* RoleDataPack::release_property() {
  
  ::NFMsg::ObjectPropertyList* temp = property_;
  property_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::ObjectPropertyList* RoleDataPack::unsafe_arena_release_property() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleDataPack.property)
  
  ::NFMsg::ObjectPropertyList* temp = property_;
  property_ = nullptr;
  return temp;
}
inline ::NFMsg::ObjectPropertyList* RoleDataPack::_internal_mutable_property() {
  
  if (property_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::ObjectPropertyList>(GetArenaForAllocation());
    property_ = p;
  }
  return property_;
}
inline ::NFMsg::ObjectPropertyList* RoleDataPack::mutable_property() {
  ::NFMsg::ObjectPropertyList* _msg = _internal_mutable_property();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleDataPack.property)
  return _msg;
}
inline void RoleDataPack::set_allocated_property(::NFMsg::ObjectPropertyList* property) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(property_);
  }
  if (property) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(property));
    if (message_arena != submessage_arena) {
      property = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, property, submessage_arena);
    }
    
  } else {
    
  }
  property_ = property;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleDataPack.property)
}

// .NFMsg.ObjectRecordList record = 3;
inline bool RoleDataPack::_internal_has_record() const {
  return this != internal_default_instance() && record_ != nullptr;
}
inline bool RoleDataPack::has_record() const {
  return _internal_has_record();
}
inline const ::NFMsg::ObjectRecordList& RoleDataPack::_internal_record() const {
  const ::NFMsg::ObjectRecordList* p = record_;
  return p != nullptr ? *p : reinterpret_cast<const ::NFMsg::ObjectRecordList&>(
      ::NFMsg::_ObjectRecordList_default_instance_);
}
inline const ::NFMsg::ObjectRecordList& RoleDataPack::record() const {
  // @@protoc_insertion_point(field_get:NFMsg.RoleDataPack.record)
  return _internal_record();
}
inline void RoleDataPack::unsafe_arena_set_allocated_record(
    ::NFMsg::ObjectRecordList* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record_);
  }
  record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NFMsg.RoleDataPack.record)
}
inline ::NFMsg::ObjectRecordList* RoleDataPack::release_record() {
  
  ::NFMsg::ObjectRecordList* temp = record_;
  record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NFMsg::ObjectRecordList* RoleDataPack::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:NFMsg.RoleDataPack.record)
  
  ::NFMsg::ObjectRecordList* temp = record_;
  record_ = nullptr;
  return temp;
}
inline ::NFMsg::ObjectRecordList* RoleDataPack::_internal_mutable_record() {
  
  if (record_ == nullptr) {
    auto* p = CreateMaybeMessage<::NFMsg::ObjectRecordList>(GetArenaForAllocation());
    record_ = p;
  }
  return record_;
}
inline ::NFMsg::ObjectRecordList* RoleDataPack::mutable_record() {
  ::NFMsg::ObjectRecordList* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:NFMsg.RoleDataPack.record)
  return _msg;
}
inline void RoleDataPack::set_allocated_record(::NFMsg::ObjectRecordList* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(record_);
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record));
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  record_ = record;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.RoleDataPack.record)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NFMsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::NFMsg::EServerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EServerState>() {
  return ::NFMsg::EServerState_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ELoginMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ELoginMode>() {
  return ::NFMsg::ELoginMode_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ReqServerListType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ReqServerListType>() {
  return ::NFMsg::ReqServerListType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_NFMsgPreGame_2eproto
